# Some Myths and Additional Extensions of Moderation Analysis



In this chapter, our Bayesian approach complicates some of Hayes's flow. We'll see how Bayesian HMC estimation can make us reconsider the value in mean centering and we'll also slip in some missing data talk.

## Truths and myths about mean-centering

> Mean-centering has been recommended in a few highly regarded books on regression analysis [e.g., @aikenMultipleRegressionTesting1991; @cohenAppliedMultipleRegression2003], and several explanations have been offered for why mean-centering should be undertaken prior to computation of the product and model estimation. The explanation that seems to have resulted in the most misunderstanding is that $X$ and $W$ are likely to be highly correlated with $XW$ and this will produce estimation problems caused by collinearity and result in poor or "strange" estimates of regression coefficients, large standard errors, and reduced power of the statistical test of the interaction. But this is, in large part, simply a myth. As I describe later, there are some reasons that mean- centering the focal antecedent or moderator variables can be a beneficial thing to do, which is why it has been *recommended* by some. However, it is incorrect to claim that it is *necessary*, that a failure to do so will lead one to incorrect inferences about moderation, or that the resulting regression coefficients are somehow strange or inherently uninterpretable. [@hayesIntroductionMediationModeration2018, pp. 304--305, *emphasis* in the original]

Here we load a couple necessary packages, load the data, and take a `glimpse()`.


```r
library(tidyverse)

glbwarm <- read_csv("data/glbwarm/glbwarm.csv")

glimpse(glbwarm)
```

```
## Rows: 815
## Columns: 7
## $ govact   <dbl> 3.6, 5.0, 6.6, 1.0, 4.0, 7.0, 6.8, 5.6, 6.0, 2.6, 1.4, 5.6, 7.0, 3.8, 3.4, 4.2, 1.0, 2…
## $ posemot  <dbl> 3.67, 2.00, 2.33, 5.00, 2.33, 1.00, 2.33, 4.00, 5.00, 5.00, 1.00, 4.00, 1.00, 5.67, 3.…
## $ negemot  <dbl> 4.67, 2.33, 3.67, 5.00, 1.67, 6.00, 4.00, 5.33, 6.00, 2.00, 1.00, 4.00, 5.00, 4.67, 2.…
## $ ideology <dbl> 6, 2, 1, 1, 4, 3, 4, 5, 4, 7, 6, 4, 2, 4, 5, 2, 6, 4, 2, 4, 4, 2, 6, 4, 4, 3, 4, 5, 4,…
## $ age      <dbl> 61, 55, 85, 59, 22, 34, 47, 65, 50, 60, 71, 60, 71, 59, 32, 36, 69, 70, 41, 48, 38, 63…
## $ sex      <dbl> 0, 0, 1, 0, 1, 0, 1, 1, 1, 1, 1, 0, 1, 0, 1, 1, 1, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 0, 0,…
## $ partyid  <dbl> 2, 1, 1, 1, 1, 2, 1, 1, 2, 3, 2, 1, 1, 1, 1, 1, 2, 3, 1, 3, 2, 1, 3, 2, 1, 1, 1, 3, 1,…
```

Before we fit our models, we'll go ahead and make our mean-centered predictors, `negemot_c` and `age_c`.


```r
glbwarm <-
  glbwarm %>% 
  mutate(negemot_c = negemot - mean(negemot),
         age_c     = age     - mean(age))
```

Now we're ready to fit Models 1 and 2. But before we do, it's worth repeating part of the text:

Let's load **brms**.


```r
library(brms)
```

As we'll see in just a bit, there are some important reasons for Bayesians using HMC to mean center that wouldn't pop up within the OLS paradigm. First let's fit `model9.1` and `model9.2`. `model9.1` follows the conventional moderation equation

$$Y = i_Y + b_1 X + b_2 W + b_3 XW + e_Y.$$

`model9.2` is our mean-centered model, which we can express formally as
$$
\begin{align*}
Y & = i_Y + b_1 \left (X - \overline X \right ) + b_2 \left (W - \overline W \right ) + b_3 \left (X - \overline X \right ) \left (W - \overline W \right ) + e_Y, \; \text{or more simply} \\
& = i_Y + b_1 X' + b_2 W' + b_3 X'W' + e_Y,
\end{align*}
$$
where $X' = \left (X - \overline X \right)$ and so on.


```r
model9.1 <- 
  brm(data = glbwarm, 
      family = gaussian,
      govact ~ 1 + negemot + age + negemot:age,
      cores = 4,
      file = "fits/model09.01")

model9.2 <- 
  update(model9.1, 
         newdata = glbwarm,
         govact ~ 1 + negemot_c + age_c + negemot_c:age_c,
         cores = 4,
         file = "fits/model09.02")
```

As with Hayes's OLS models, our HMC models yield the same Bayesian $R^2$ distributions, within simulation error.


```r
bayes_R2(model9.1) %>% round(digits = 3)
```

```
##    Estimate Est.Error  Q2.5 Q97.5
## R2    0.354     0.021 0.311 0.394
```

```r
bayes_R2(model9.2) %>% round(digits = 3)
```

```
##    Estimate Est.Error  Q2.5 Q97.5
## R2    0.354     0.022 0.309 0.394
```

Our model summaries also correspond nicely with those at the top of Table 9.1.


```r
print(model9.1, digits = 3)
```

```
##  Family: gaussian 
##   Links: mu = identity; sigma = identity 
## Formula: govact ~ 1 + negemot + age + negemot:age 
##    Data: glbwarm (Number of observations: 815) 
## Samples: 4 chains, each with iter = 2000; warmup = 1000; thin = 1;
##          total post-warmup samples = 4000
## 
## Population-Level Effects: 
##             Estimate Est.Error l-95% CI u-95% CI  Rhat Bulk_ESS Tail_ESS
## Intercept      4.339     0.328    3.692    4.994 1.001     1599     1650
## negemot        0.145     0.084   -0.023    0.308 1.001     1571     1416
## age           -0.031     0.006   -0.043   -0.018 1.001     1627     1411
## negemot:age    0.007     0.002    0.004    0.010 1.001     1622     1635
## 
## Family Specific Parameters: 
##       Estimate Est.Error l-95% CI u-95% CI  Rhat Bulk_ESS Tail_ESS
## sigma    1.096     0.027    1.045    1.149 1.002     2354     2182
## 
## Samples were drawn using sampling(NUTS). For each parameter, Bulk_ESS
## and Tail_ESS are effective sample size measures, and Rhat is the potential
## scale reduction factor on split chains (at convergence, Rhat = 1).
```

```r
print(model9.2, digits = 3)
```

```
##  Family: gaussian 
##   Links: mu = identity; sigma = identity 
## Formula: govact ~ negemot_c + age_c + negemot_c:age_c 
##    Data: glbwarm (Number of observations: 815) 
## Samples: 4 chains, each with iter = 2000; warmup = 1000; thin = 1;
##          total post-warmup samples = 4000
## 
## Population-Level Effects: 
##                 Estimate Est.Error l-95% CI u-95% CI  Rhat Bulk_ESS Tail_ESS
## Intercept          4.596     0.038    4.521    4.671 1.001     3572     2586
## negemot_c          0.501     0.025    0.453    0.549 1.001     3723     2696
## age_c             -0.005     0.002   -0.010   -0.001 1.000     5170     3260
## negemot_c:age_c    0.007     0.002    0.004    0.010 1.004     5602     3134
## 
## Family Specific Parameters: 
##       Estimate Est.Error l-95% CI u-95% CI  Rhat Bulk_ESS Tail_ESS
## sigma    1.097     0.027    1.044    1.152 1.001     3385     2774
## 
## Samples were drawn using sampling(NUTS). For each parameter, Bulk_ESS
## and Tail_ESS are effective sample size measures, and Rhat is the potential
## scale reduction factor on split chains (at convergence, Rhat = 1).
```

However, notice the 'Bulk_ESS' and 'Tail_ESS' columns. The values for `model9.2` were substantially larger than those for `model9.1`. These columns denote the number of effective samples (a.k.a. the effective sample size). Versions of **brms** before 2.10.0 returned a single effective sample size (ESS) value per parameter. We will cover where the change came from in a bit. But first, recall that we've been using **brms** defaults, which results in 4 HMC chains, each of which contains 2,000 draws (iterations), the first 1,000 of which are warmup values. After we discard the warmup values, that leaves 1,000 draws from each chain--4,000 total. As it turns out, Markov chains, and thus HMC chains, are typically *autocorrelated*, which means that each draw is partially dependent on the previous draw. Ideally, the autocorrelations are near zero. That's often not the case.

The [**bayesplot** package](https://github.com/stan-dev/bayesplot) offers a variety of [diagnostic plots](https://cran.r-project.org/web/packages/bayesplot/vignettes/visual-mcmc-diagnostics.html#effective-sample-size). Here we'll use the `mcmc_acf()` function to make autocorrelation plots for all model parameters. Note that when we add `add_chain = T` to `brms::posterior_samples()`, we add an index to the data that allows us to keep track of which iteration comes from which chain. That index will come in handy for our `mcmc_acf()` plots.

But before we get there, we'll be using an [xkcd](https://xkcd.com)-inspired theme with help from the [**xkcd** package](https://CRAN.R-project.org/package=xkcd) [@torres-manzaneraXkcdPlottingGgplot22018] for our plots in this chapter.


```r
# install.packages("xkcd", dependencies = T)

library(xkcd)
```

If you haven't used the **xkcd** package, before, you might also need to take a few extra steps outlined in the paper by Torres-Manzanera [-@torres-manzaneraXkcdPlottingXKCD], [*xkcd: Plotting XKCD graphs*](https://cran.r-project.org/web/packages/xkcd/vignettes/xkcd-intro.pdf), part of which requires help from the [**extrafont** package](https://cran.r-project.org/package=extrafont/) [@winstonchangExtrafontToolsUsing2014].


```r
library(extrafont)

download.file("http://simonsoftware.se/other/xkcd.ttf",
              dest = "xkcd.ttf", mode = "wb")
 
system("mkdir ~/.fonts")
system("cp xkcd.ttf  ~/.fonts")
# this line of code returned an error message
# font_import(pattern = "[X/x]kcd", prompt = FALSE)

# this line from (https://stackoverflow.com/questions/49221040/error-in-font-import-while-installing-xkcd-font) fixed the problem
font_import(path = "~/.fonts", pattern = "[X/x]kcd", prompt=FALSE)
fonts()
fonttable()
 if(.Platform$OS.type != "unix") {
   ## Register fonts for Windows bitmap output
   loadfonts(device="win")
 } else {
   loadfonts()
 }
```

After installing, I still experienced error messages, which were alleviated after I followed [these steps outlined by Remi.b](https://stackoverflow.com/questions/48553545/polygon-edge-not-found-with-the-xkcd-package). You may or may not need them.

But anyways, here are our `mcmc_acf()` plots.


```r
library(bayesplot)

post1 <- posterior_samples(model9.1, add_chain = T)
mcmc_acf(post1, 
         pars = c("b_Intercept", "b_negemot", "b_age", "b_negemot:age", "sigma"),
         lags = 4) +
  theme_xkcd()
```

<img src="09_files/figure-html/unnamed-chunk-9-1.png" width="768" />

```r
post2 <- posterior_samples(model9.2, add_chain = T)
mcmc_acf(post2, 
         pars = c("b_Intercept", "b_negemot_c", "b_age_c", "b_negemot_c:age_c", "sigma"),
         lags = 4) +
  theme_xkcd() 
```

<img src="09_files/figure-html/unnamed-chunk-9-2.png" width="768" />

As it turns out, `theme_xkcd()` can't handle special characters like "_", so it returns rectangles instead. So it goes...

But again, high autocorrelations in the HMC chains have consequences for the effective sample size. In their [-@gabryVisualMCMC2020] vignette, [**Visual MCMC diagnostics using the bayesplot package**](https://CRAN.R-project.org/package=bayesplot/vignettes/visual-mcmc-diagnostics.html), Gabry and Modrák wrote:

> The effective sample size is an estimate of the number of independent draws from the posterior distribution of the estimand of interest. Because the draws within a Markov chain are *not* independent if there is autocorrelation, the effective sample size, $n_{eff}$, will be smaller than the total sample size, $N$. The larger the ratio of $n_{eff}$ to $N$ the better.

In that quote, they spoke as if there was only one measure of ESS. Though this has been the case for some time, times have changed. In a [-@vehtariRanknormalizationFoldingLocalization2019] [paper](https://arxiv.org/pdf/1903.08008.pdf), Stan-team allstars Vehtari, Gelman, Simpson, Carpenter, and Bürkner proposed two measures of ESS: "bulk-ESS" and "tail-ESS." From their paper, we read:

> if you plan to report quantile estimates or posterior intervals, we strongly suggest assessing the
convergence of the chains for these quantiles. In Section 4.3 we show that convergence of Markov chains is not uniform across the parameter space and propose diagnostics and effective sample sizes specifically for extreme quantiles. This is *different* from the standard ESS estimate (which we refer to as the "bulk-ESS"), which mainly assesses how well the centre of the distribution is resolved. Instead, these "tail-ESS" measures allow the user to estimate the MCSE for interval estimates. (p. 5, *emphasis* in the original)

You can read the paper for technical details. In short, the `Bulk_ESS` in the output of **brms** 2.10.0 and up is what was previously referred to as `Eff.Sample`, the effective sample size. This indexed the number of effective samples in "the centre of the" posterior distribution (i.e., the posterior mean or median). But since we also care about uncertainty in our models, we also care about how well we have characterized the tails of the posterior distribution in 95% intervals and such. The new `Tail_ESS` in **brms** output allows us to gauge the effective sample size for those intervals.

The `Bulk_ESS` and `Tail_ESS` values were all well above 2,000 with `model9.2` and the autocorrelations were very low, too. `model9.1` had higher autocorrelations and lower ESS values. The upshot is that even though we have 4,000 samples for each parameter, those samples don't necessarily give us the same quality of information fully independent samples would. `Bulk_ESS` and `Tail_ESS` values help you determine how concerned you should be. And, as it turns out, things like centering can help increase a models `Bulk_ESS` and `Tail_ESS` values.

Wading in further, we can use the `neff_ratio()` function to collect the $n_{eff}$ to $N$ ratio for each model parameter and then use `mcmc_neff()` to make a visual diagnostic. Here we do so for `model9.1` and `model9.2`.


```r
ratios_model9.1 <- 
  neff_ratio(model9.1, 
             pars = c("b_Intercept", "b_negemot", "b_age", "b_negemot:age", "sigma"))

ratios_model9.2 <- 
  neff_ratio(model9.2,
             pars = c("b_Intercept", "b_negemot_c", "b_age_c", "b_negemot_c:age_c", "sigma"))

mcmc_neff(ratios_model9.1) + 
  yaxis_text(hjust = 0) +
  theme_xkcd()
```

<img src="09_files/figure-html/unnamed-chunk-10-1.png" width="768" />

```r
mcmc_neff(ratios_model9.2) + 
  yaxis_text(hjust = 0) +
  theme_xkcd()
```

<img src="09_files/figure-html/unnamed-chunk-10-2.png" width="768" />

Although none of the $n_{eff}$ to $N$ ratios were in the shockingly-low range for either model, there were substantially higher for `model9.2`.

In addition to autocorrelations and $n_{eff}$ to $N$ ratios, there is also the issue that the parameters in the model can themselves be correlated. If you like a visual approach, you can use `brms::pairs()` to retrieve histograms for each parameter along with scatter plots showing the shape of their correlations. Here we'll use the `off_diag_args` argument to customize some of the plot settings.


```r
pairs(model9.1,
      off_diag_args = list(size = 1/10,
                           alpha = 1/5))
```

<img src="09_files/figure-html/unnamed-chunk-11-1.png" width="624" />

```r
pairs(model9.2,
      off_diag_args = list(size = 1/10,
                           alpha = 1/5))
```

<img src="09_files/figure-html/unnamed-chunk-11-2.png" width="624" />

When fitting models with HMC, centering can make a difference for the parameter correlations. If you prefer a more numeric approach, `vcov()` will yield the variance/covariance matrix--or correlation matrix when using `correlation = T`--for the parameters in a model.


```r
vcov(model9.1, correlation = T) %>% round(digits = 2)
```

```
##             Intercept negemot   age negemot:age
## Intercept        1.00   -0.93 -0.96        0.88
## negemot         -0.93    1.00  0.90       -0.95
## age             -0.96    0.90  1.00       -0.93
## negemot:age      0.88   -0.95 -0.93        1.00
```

```r
vcov(model9.2, correlation = T) %>% round(digits = 2)
```

```
##                 Intercept negemot_c age_c negemot_c:age_c
## Intercept            1.00      0.00 -0.02            0.06
## negemot_c            0.00      1.00  0.07           -0.08
## age_c               -0.02      0.07  1.00            0.00
## negemot_c:age_c      0.06     -0.08  0.00            1.00
```

*And so wait, what does that even mean for a parameter to correlate with another parameter?* you might ask. Fair enough. Let's compute a parameter correlation step by step. The first step requires `posterior_samples()`.


```r
post <- posterior_samples(model9.1)

head(post)
```

```
##   b_Intercept b_negemot       b_age b_negemot:age    sigma      lp__
## 1    4.267039 0.1669059 -0.03210406   0.007280709 1.123790 -1233.858
## 2    4.322829 0.1939527 -0.03006599   0.006139089 1.063223 -1233.707
## 3    3.635584 0.3306825 -0.02198835   0.004962000 1.083873 -1237.296
## 4    4.069018 0.2093848 -0.02379821   0.005936223 1.123674 -1235.817
## 5    4.418928 0.1815846 -0.03104694   0.006656904 1.143549 -1237.431
## 6    4.350403 0.1691090 -0.03257617   0.007015670 1.080829 -1233.019
```

Now we've put our posterior iterations into a data object, `post`, we can make a scatter plot of two parameters. Here we'll choose `b_negemot` and the interaction coefficient, `b_negemot:age`.


```r
post %>% 
  ggplot(aes(x = b_negemot, y = `b_negemot:age`)) +
  geom_point(size = 1/10, alpha = 1/5) +
  labs(subtitle = "Each dot is the parameter pair\nfrom a single iteration. Looking\nacross the 4,000 total posterior\niterations, it becomes clear the\ntwo parameters are highly\nnegatively correlated.") +
  theme_xkcd()
```

<img src="09_files/figure-html/unnamed-chunk-14-1.png" width="384" />

And indeed, the Pearson's correlation coefficient is strong.


```r
cor(post$b_negemot, post$`b_negemot:age`)
```

```
## [1] -0.9546606
```

And what was that part from the `vcov()` output, again?


```r
vcov(model9.1, correlation = T)["negemot", "negemot:age"]
```

```
## [1] -0.9546606
```

Boom! That's where those correlations come from.

This entire topic of HMC diagnostics can seem baffling, especially when compared to the simplicity of OLS. If this is your first introduction, you might want to watch lectures [10](https://www.youtube.com/watch?v=BWEtS3HuU5A&list=PLDcUM9US4XdM9_N6XUUFrhghGJ4K25bFc) and [11](https://www.youtube.com/watch?v=13mEekRdOcQ&list=PLDcUM9US4XdM9_N6XUUFrhghGJ4K25bFc) from McElreath's [Statistical Rethinking Fall 2017 lecture series](https://www.youtube.com/playlist?list=PLDcUM9US4XdM9_N6XUUFrhghGJ4K25bFc). Accordingly, you might check out Chapter 8 of his [-@mcelreathStatisticalRethinkingBayesian2015] text, Chapter 9 of his [-@mcelreathStatisticalRethinkingBayesian2020] text, and either of my ebooks translating his work into **brms** and **tidyverse** code [@kurzStatisticalRethinkingBrms2020; @kurzStatisticalRethinkingSecondEd2021].

### The effect of mean-centering on multicollinearity and the standard error of $b_3$.

This can be difficult to keep track of, but what we just looked at were the correlations among **model parameters**. These are *not* the same as correlations among **variables**. As such, those correlations are not the same as those in Table 9.2. But we can get those, too. First we'll have to do a little more data processing to get all the necessary mean-centered variables and standardized variables.


```r
glbwarm <-
  glbwarm %>% 
  mutate(negemot_x_age     = negemot   * age,
         negemot_c_x_age_c = negemot_c * age_c,
         negemot_z         = (negemot - mean(negemot)) / sd(negemot),
         age_z             = (age     - mean(age)    ) / sd(age)) %>% 
  mutate(negemot_z_x_age_z = negemot_z * age_z)
```

And recall that to get our sweet Bayesian correlations, we use the multivariate `mvbind()` syntax to fit an intercepts-only model. Here we do that for all three of the Table 9.2 sections.


```r
model9.3 <- 
  brm(data = glbwarm, 
      family = gaussian,
      mvbind(negemot, age, negemot_x_age) ~ 1,
      cores = 4,
      file = "fits/model09.03")

model9.4 <- 
  brm(data = glbwarm, 
      family = gaussian,
      mvbind(negemot_c, age_c, negemot_c_x_age_c) ~ 1,
      cores = 4,
      file = "fits/model09.04")

model9.5 <- 
  brm(data = glbwarm, 
      family = gaussian,
      mvbind(negemot_z, age_z, negemot_z_x_age_z) ~ 1,
      cores = 4,
      file = "fits/model09.05")
```

Here are their summaries.


```r
print(model9.3, digits = 3)
```

```
##  Family: MV(gaussian, gaussian, gaussian) 
##   Links: mu = identity; sigma = identity
##          mu = identity; sigma = identity
##          mu = identity; sigma = identity 
## Formula: negemot ~ 1 
##          age ~ 1 
##          negemot_x_age ~ 1 
##    Data: glbwarm (Number of observations: 815) 
## Samples: 4 chains, each with iter = 2000; warmup = 1000; thin = 1;
##          total post-warmup samples = 4000
## 
## Population-Level Effects: 
##                       Estimate Est.Error l-95% CI u-95% CI  Rhat Bulk_ESS Tail_ESS
## negemot_Intercept        3.558     0.054    3.452    3.664 1.001     3110     2424
## age_Intercept           49.529     0.563   48.422   50.670 1.001     3440     2451
## negemotxage_Intercept  174.742     3.467  167.744  181.481 1.002     2756     2064
## 
## Family Specific Parameters: 
##                   Estimate Est.Error l-95% CI u-95% CI  Rhat Bulk_ESS Tail_ESS
## sigma_negemot        1.530     0.037    1.460    1.606 1.002     2993     2775
## sigma_age           16.359     0.410   15.576   17.183 1.001     3159     2857
## sigma_negemotxage   97.463     2.381   93.033  102.220 1.004     2539     2047
## 
## Residual Correlations: 
##                             Estimate Est.Error l-95% CI u-95% CI  Rhat Bulk_ESS Tail_ESS
## rescor(negemot,age)           -0.059     0.034   -0.127    0.008 1.001     2764     2565
## rescor(negemot,negemotxage)    0.765     0.015    0.736    0.793 1.001     2784     2790
## rescor(age,negemotxage)        0.547     0.024    0.499    0.593 1.001     3158     2595
## 
## Samples were drawn using sampling(NUTS). For each parameter, Bulk_ESS
## and Tail_ESS are effective sample size measures, and Rhat is the potential
## scale reduction factor on split chains (at convergence, Rhat = 1).
```

```r
print(model9.4, digits = 3)
```

```
##  Family: MV(gaussian, gaussian, gaussian) 
##   Links: mu = identity; sigma = identity
##          mu = identity; sigma = identity
##          mu = identity; sigma = identity 
## Formula: negemot_c ~ 1 
##          age_c ~ 1 
##          negemot_c_x_age_c ~ 1 
##    Data: glbwarm (Number of observations: 815) 
## Samples: 4 chains, each with iter = 2000; warmup = 1000; thin = 1;
##          total post-warmup samples = 4000
## 
## Population-Level Effects: 
##                         Estimate Est.Error l-95% CI u-95% CI  Rhat Bulk_ESS Tail_ESS
## negemotc_Intercept        -0.001     0.054   -0.108    0.105 1.000     7090     3028
## agec_Intercept            -0.002     0.566   -1.084    1.098 1.001     8140     2918
## negemotcxagec_Intercept   -1.415     0.834   -3.039    0.211 1.000     7757     2924
## 
## Family Specific Parameters: 
##                     Estimate Est.Error l-95% CI u-95% CI  Rhat Bulk_ESS Tail_ESS
## sigma_negemotc         1.532     0.038    1.460    1.612 1.001     6747     2939
## sigma_agec            16.367     0.407   15.590   17.183 1.002     7294     3122
## sigma_negemotcxagec   24.228     0.593   23.103   25.388 1.001     7204     2968
## 
## Residual Correlations: 
##                                Estimate Est.Error l-95% CI u-95% CI  Rhat Bulk_ESS Tail_ESS
## rescor(negemotc,agec)            -0.057     0.034   -0.125    0.010 1.000     7403     3038
## rescor(negemotc,negemotcxagec)    0.092     0.034    0.026    0.158 1.000     7912     3276
## rescor(agec,negemotcxagec)       -0.015     0.034   -0.080    0.054 1.001     7755     3576
## 
## Samples were drawn using sampling(NUTS). For each parameter, Bulk_ESS
## and Tail_ESS are effective sample size measures, and Rhat is the potential
## scale reduction factor on split chains (at convergence, Rhat = 1).
```

```r
print(model9.5, digits = 3)
```

```
##  Family: MV(gaussian, gaussian, gaussian) 
##   Links: mu = identity; sigma = identity
##          mu = identity; sigma = identity
##          mu = identity; sigma = identity 
## Formula: negemot_z ~ 1 
##          age_z ~ 1 
##          negemot_z_x_age_z ~ 1 
##    Data: glbwarm (Number of observations: 815) 
## Samples: 4 chains, each with iter = 2000; warmup = 1000; thin = 1;
##          total post-warmup samples = 4000
## 
## Population-Level Effects: 
##                         Estimate Est.Error l-95% CI u-95% CI  Rhat Bulk_ESS Tail_ESS
## negemotz_Intercept        -0.000     0.035   -0.067    0.067 1.002     7105     2550
## agez_Intercept             0.001     0.035   -0.066    0.069 1.000     7356     2738
## negemotzxagez_Intercept   -0.057     0.034   -0.122    0.008 1.003     5934     3095
## 
## Family Specific Parameters: 
##                     Estimate Est.Error l-95% CI u-95% CI  Rhat Bulk_ESS Tail_ESS
## sigma_negemotz         1.003     0.025    0.956    1.052 1.002     6363     3062
## sigma_agez             1.002     0.025    0.956    1.053 1.000     8045     3189
## sigma_negemotzxagez    0.972     0.025    0.923    1.023 1.003     7169     2681
## 
## Residual Correlations: 
##                                Estimate Est.Error l-95% CI u-95% CI  Rhat Bulk_ESS Tail_ESS
## rescor(negemotz,agez)            -0.057     0.035   -0.126    0.009 1.000     7023     2999
## rescor(negemotz,negemotzxagez)    0.091     0.035    0.023    0.158 1.001     7368     3093
## rescor(agez,negemotzxagez)       -0.016     0.035   -0.085    0.052 1.001     6784     2647
## 
## Samples were drawn using sampling(NUTS). For each parameter, Bulk_ESS
## and Tail_ESS are effective sample size measures, and Rhat is the potential
## scale reduction factor on split chains (at convergence, Rhat = 1).
```

A more condensed way to get that information might be with the `brms::VarCorr()` function. Just make sure to tack `$residual__$cor` onto the end.


```r
VarCorr(model9.3)$residual__$cor %>% 
  round(digits = 3)
```

```
## , , negemot
## 
##             Estimate Est.Error   Q2.5 Q97.5
## negemot        1.000     0.000  1.000 1.000
## age           -0.059     0.034 -0.127 0.008
## negemotxage    0.765     0.015  0.736 0.793
## 
## , , age
## 
##             Estimate Est.Error   Q2.5 Q97.5
## negemot       -0.059     0.034 -0.127 0.008
## age            1.000     0.000  1.000 1.000
## negemotxage    0.547     0.024  0.499 0.593
## 
## , , negemotxage
## 
##             Estimate Est.Error  Q2.5 Q97.5
## negemot        0.765     0.015 0.736 0.793
## age            0.547     0.024 0.499 0.593
## negemotxage    1.000     0.000 1.000 1.000
```

For the sake of space, I'll let you check that out for `model9.4` and `model9.5`. If you're tricky with your `VarCorr()` indexing, you can also get the model-implied variances.


```r
VarCorr(model9.3)$residual__$cov[1, , "negemot"] %>% round(digits = 3)
```

```
##  Estimate Est.Error      Q2.5     Q97.5 
##     2.343     0.113     2.132     2.579
```

```r
VarCorr(model9.3)$residual__$cov[2, , "age"] %>% round(digits = 3)
```

```
##  Estimate Est.Error      Q2.5     Q97.5 
##   267.789    13.441   242.603   295.247
```

```r
VarCorr(model9.3)$residual__$cov[3, , "negemotxage"] %>% round(digits = 3)
```

```
##  Estimate Est.Error      Q2.5     Q97.5 
##  9504.797   464.918  8655.073 10448.927
```

And if you're like totally lost with all this indexing, you might execute `VarCorr(correlations1) %>% str()` and spend a little time looking at what `VarCorr()` returns.

On page 309, Hayes explained why the OLS variance for $b_3$ is unaffected by mean centering. The story was similar for our HMC model, too.


```r
fixef(model9.1)["negemot:age", "Est.Error"]
```

```
## [1] 0.001579179
```

```r
fixef(model9.2)["negemot_c:age_c", "Est.Error"]
```

```
## [1] 0.001586178
```

For more details, you might also see the [*Standardizing predictors and outputs*](https://mc-stan.org/docs/2_25/stan-users-guide/standardizing-predictors-and-outputs.html) subsection of Chapter 22 in the *Stan user's guide* [@standevelopmentteamStanUserGuide2021]--[Stan](http://mc-stan.org), of course, being the computational engine underneath our **brms** hood.

### The effect of mean-centering on $b_1$, $b_2$, and their ~~standard errors~~ posterior $SD$s.

> A second explanation given for why mean-centering is preferred is that it makes $b_1$ and $b_2$, the regression coefficients for $X$ and $W$, more meaningful. This is generally true and thus not a myth, although it is not necessarily true in all circumstances... .
>
> Mean-centering $X$ and $W$ prior to computation of the product and estimation of the model will produce $b_1$ and $b_2$ that are always meaningful, rather than meaningful only when $X$ and/or $W$ are meaningful when equal to zero... [After mean centering,] $b_1$ estimates the difference in $Y$ between two cases that differ by one unit on $X$ among cases that are *average* on $W$. Similarly, $b_2$ estimates the difference in $Y$ between two cases that differ by one unit on $W$ among cases that are *average* on $X$. These will always estimate conditional effects of $X$ on $Y$ within the range of the data, and they can always be interpreted. (p. 310. *emphasis* in the original)

If you only care about posterior means, you can use `model9.1` to reproduce the results at the bottom of page 310 like this.


```r
fixef(model9.1)["negemot", 1] + 
  fixef(model9.1)["negemot:age", 1] * mean(glbwarm$age)
```

```
## [1] 0.5006911
```

Here's the same computation using `model9.2`.


```r
fixef(model9.2)["negemot_c", 1] + 
  fixef(model9.2)["negemot_c:age_c", 1] * mean(glbwarm$age_c)
```

```
## [1] 0.5006193
```

But we're proper Bayesians and like a summary of the spread in the posterior. So we'll evoke `posterior_samples()` and the other usual steps, this time just focusing on `model9.1`.


```r
post <- posterior_samples(model9.1)

post %>% 
  transmute(our_contidional_effect_given_W_bar = b_negemot + `b_negemot:age` * mean(glbwarm$age)) %>%
  summarize(mean = mean(our_contidional_effect_given_W_bar),
            sd   = sd(our_contidional_effect_given_W_bar)) %>% 
  round(digits = 3)
```

```
##    mean    sd
## 1 0.501 0.025
```

And note how the standard error Hayes computed at the top of page 311 corresponds nicely with the posterior $SD$ we just computed. Hayes employed a fancy formula; we just used `sd()`. At any rate, the main message is centering did not effect our estimate of the conditional effect of $X$. It turns out $(\theta_{X \rightarrow Y} | W) = \left (\theta_{\overline X \rightarrow Y} | \overline W \right)$.

### The ~~centering option in PROCESS~~.

I'm not aware of a similar function in **brms**. You'll have to use your data wrangling skills.

## The estimation and interpretation of standardized regression coefficients in a moderation analysis

> Mean-centering does nothing to change the scaling of regression coefficients. Whether or not mean-centering is used when estimating a model of the form $\hat Y = i_Y + b_1 X + b_2 W + b_3 XW$, $b_1$, $b_2$, and $b_3$ are interpreted with respect to the measured metrics of $X$, $W$, and $Y$ (i.e., in *unstandardized* form). Although [Hayes] generally prefer[s] to report and interpret regression analyses based on unstandardized coefficients, it is possible to generate regression coefficients that are analogous to standardized regression coefficients in regression models without a product term as a predictor. However, one must be careful when doing so. (p. 313, *emphasis* in the original)

### Variant 1.

We've already computed standardized predictors. Now we just need to standardize the criterion, `govact`.


```r
glbwarm <-
  glbwarm %>% 
  mutate(govact_z = (govact - mean(govact)) / sd(govact))
```

Fit the model.


```r
model9.6 <- 
  update(model9.1, 
         newdata = glbwarm,
         govact_z ~ 1 + negemot_z + age_z + negemot_z:age_z,
         cores = 4,
         file = "fits/model09.06")
```

Check the Bayesian $R^2$.


```r
bayes_R2(model9.6) %>% round(digits = 3)
```

```
##    Estimate Est.Error Q2.5 Q97.5
## R2    0.354     0.022 0.31 0.395
```

Check the parameter summaries.


```r
print(model9.6, digits = 3)
```

```
##  Family: gaussian 
##   Links: mu = identity; sigma = identity 
## Formula: govact_z ~ negemot_z + age_z + negemot_z:age_z 
##    Data: glbwarm (Number of observations: 815) 
## Samples: 4 chains, each with iter = 2000; warmup = 1000; thin = 1;
##          total post-warmup samples = 4000
## 
## Population-Level Effects: 
##                 Estimate Est.Error l-95% CI u-95% CI  Rhat Bulk_ESS Tail_ESS
## Intercept          0.008     0.028   -0.047    0.062 1.001     5516     2595
## negemot_z          0.563     0.029    0.504    0.618 1.002     5455     2970
## age_z             -0.063     0.028   -0.117   -0.009 1.001     5523     3403
## negemot_z:age_z    0.131     0.029    0.072    0.188 1.000     5539     3157
## 
## Family Specific Parameters: 
##       Estimate Est.Error l-95% CI u-95% CI  Rhat Bulk_ESS Tail_ESS
## sigma    0.806     0.020    0.767    0.846 1.000     5497     2852
## 
## Samples were drawn using sampling(NUTS). For each parameter, Bulk_ESS
## and Tail_ESS are effective sample size measures, and Rhat is the potential
## scale reduction factor on split chains (at convergence, Rhat = 1).
```

If you go all the way up back to Table 9.1, you'll see our results are pretty similar to those in the text.

### Variant 2.

This time we need to standardize our interaction term, `negemot_x_age_z`, by hand.


```r
glbwarm <-
  glbwarm %>% 
  mutate(negemot_x_age_z = (negemot_x_age - mean(negemot_x_age)) / sd(negemot_x_age))
```

Now we're ready to `update()`.


```r
model9.7 <- 
  update(model9.1, 
         newdata = glbwarm,
         govact_z ~ 1 + negemot_z + age_z + negemot_x_age_z,
         cores = 4,
         file = "fits/model09.07")
```


```r
bayes_R2(model9.7) %>% round(digits = 3)
```

```
##    Estimate Est.Error  Q2.5 Q97.5
## R2    0.354     0.022 0.309 0.395
```


```r
print(model9.7, digits = 3)
```

```
##  Family: gaussian 
##   Links: mu = identity; sigma = identity 
## Formula: govact_z ~ negemot_z + age_z + negemot_x_age_z 
##    Data: glbwarm (Number of observations: 815) 
## Samples: 4 chains, each with iter = 2000; warmup = 1000; thin = 1;
##          total post-warmup samples = 4000
## 
## Population-Level Effects: 
##                 Estimate Est.Error l-95% CI u-95% CI  Rhat Bulk_ESS Tail_ESS
## Intercept         -0.000     0.028   -0.053    0.054 1.001     2728     2238
## negemot_z          0.164     0.097   -0.028    0.352 1.003     1311     1662
## age_z             -0.369     0.075   -0.517   -0.226 1.004     1308     1761
## negemot_x_age_z    0.512     0.116    0.289    0.739 1.004     1308     1719
## 
## Family Specific Parameters: 
##       Estimate Est.Error l-95% CI u-95% CI  Rhat Bulk_ESS Tail_ESS
## sigma    0.807     0.020    0.769    0.846 1.001     2633     2463
## 
## Samples were drawn using sampling(NUTS). For each parameter, Bulk_ESS
## and Tail_ESS are effective sample size measures, and Rhat is the potential
## scale reduction factor on split chains (at convergence, Rhat = 1).
```

The results correspond nicely to those in Table 9.1, too.

## A caution on manual centering and standardization [because of missing data]

It's worthwhile considering the issue of listwise deletion when data are partially missing. The **brms** default is to delete rows with missingness, `NA` in **R**, for the predictors. However, **brms** allows users to perform one-step Bayesian imputation for missing values using the `mi()` syntax. You can learn all the details in Bürkner's [-@Bürkner2021HandleMissingValues] vignette, [*Handle missing values with brms*](https://CRAN.R-project.org/package=brms/vignettes/brms_missings.html). First we'll fit see what happens when you fit a model in **brms** when some of the `negemot_z` values are missing, but without using the `mi()` syntax. And of course before we do that, we'll make a `negemot_z_missing` variable, which is identical to `negemot_z`, but about 10% of the values are missing.


```r
set.seed(9)

glbwarm <-
  glbwarm %>% 
  mutate(missing = rbinom(n = n(), size = 1, prob = .1)) %>% 
  mutate(negemot_z_missing = ifelse(missing == 1, NA, negemot_z))
```

If you've never used `rbinom()` before, execute `?rbinom` or look it up in your favorite web search engine. Here's our listwise deletion model, which corresponds to what you'd get from a typical OLS-based program.


```r
model9.8 <- 
  update(model9.6, 
         newdata = glbwarm,
         govact_z ~ 1 + negemot_z_missing + age_z + negemot_z_missing:age_z,
         cores = 4,
         file = "fits/model09.08")
```

Let's compare the listwise deletion results with the model based on all the data.


```r
print(model9.6)
```

```
##  Family: gaussian 
##   Links: mu = identity; sigma = identity 
## Formula: govact_z ~ negemot_z + age_z + negemot_z:age_z 
##    Data: glbwarm (Number of observations: 815) 
## Samples: 4 chains, each with iter = 2000; warmup = 1000; thin = 1;
##          total post-warmup samples = 4000
## 
## Population-Level Effects: 
##                 Estimate Est.Error l-95% CI u-95% CI Rhat Bulk_ESS Tail_ESS
## Intercept           0.01      0.03    -0.05     0.06 1.00     5516     2595
## negemot_z           0.56      0.03     0.50     0.62 1.00     5455     2970
## age_z              -0.06      0.03    -0.12    -0.01 1.00     5523     3403
## negemot_z:age_z     0.13      0.03     0.07     0.19 1.00     5539     3157
## 
## Family Specific Parameters: 
##       Estimate Est.Error l-95% CI u-95% CI Rhat Bulk_ESS Tail_ESS
## sigma     0.81      0.02     0.77     0.85 1.00     5497     2852
## 
## Samples were drawn using sampling(NUTS). For each parameter, Bulk_ESS
## and Tail_ESS are effective sample size measures, and Rhat is the potential
## scale reduction factor on split chains (at convergence, Rhat = 1).
```

```r
print(model9.8)
```

```
##  Family: gaussian 
##   Links: mu = identity; sigma = identity 
## Formula: govact_z ~ negemot_z_missing + age_z + negemot_z_missing:age_z 
##    Data: glbwarm (Number of observations: 731) 
## Samples: 4 chains, each with iter = 2000; warmup = 1000; thin = 1;
##          total post-warmup samples = 4000
## 
## Population-Level Effects: 
##                         Estimate Est.Error l-95% CI u-95% CI Rhat Bulk_ESS Tail_ESS
## Intercept                   0.00      0.03    -0.05     0.06 1.00     5017     3062
## negemot_z_missing           0.57      0.03     0.51     0.63 1.00     5356     3242
## age_z                      -0.05      0.03    -0.10     0.01 1.00     5433     3454
## negemot_z_missing:age_z     0.12      0.03     0.06     0.18 1.00     5760     3023
## 
## Family Specific Parameters: 
##       Estimate Est.Error l-95% CI u-95% CI Rhat Bulk_ESS Tail_ESS
## sigma     0.81      0.02     0.77     0.85 1.00     4488     3171
## 
## Samples were drawn using sampling(NUTS). For each parameter, Bulk_ESS
## and Tail_ESS are effective sample size measures, and Rhat is the potential
## scale reduction factor on split chains (at convergence, Rhat = 1).
```

In this case, the model results were similar to those based on all the data because we used `rbinom()` to delete the predictor values completely at random. With real data and real-live missing data mechanisms, the situation isn't often so rosy. But anyway, the real story, here, is the `Data: glbwarm (Number of observations: n)` line at the top of the `print()` outputs. The number, $n$, was 815 in the model using all the data and 731 for the one based on listwise deletion. That's a lot of missing information.

The `mi()` syntax will allow us to use all the rows in a model, even if one or more of the predictors contain missing values. The syntax makes the model a multivariate model in that now we'll be modeling both `govact_z` *and* `negemot_z_missing`. As we've covered in prior chapters, there are multiple ways to write a multivariate model in **brms** [see @Bürkner2021Multivariate]. One nice way is to write the model for each criterion separately in a `bf()` statement. You combine the `bf()` statements together with the `+` operator. And for models like the ones in Hayes's text, you'll also want to tack on `set_rescor(FALSE)`. You can do this within the `brm()` function, as usual. But I find that this clutters the code up more than I like. So another approach is to save the combination of `bf()` statements as an object.


```r
my_model <- 
  bf(govact_z  ~ 1 + mi(negemot_z_missing) + age_z + mi(negemot_z_missing):age_z) + 
  bf(negemot_z_missing | mi() ~ 1) + 
  set_rescor(FALSE)
```

With our multivariate formula saved as `my_model`, we're ready to plug it into `brm()` and fit.


```r
model9.9 <- 
  brm(data = glbwarm,
      family = gaussian,
      my_model,
      cores = 4,
      file = "fits/model09.09")
```

Let's see what we've done.


```r
print(model9.9)
```

```
##  Family: MV(gaussian, gaussian) 
##   Links: mu = identity; sigma = identity
##          mu = identity; sigma = identity 
## Formula: govact_z ~ 1 + mi(negemot_z_missing) + age_z + mi(negemot_z_missing):age_z 
##          negemot_z_missing | mi() ~ 1 
##    Data: glbwarm (Number of observations: 815) 
## Samples: 4 chains, each with iter = 2000; warmup = 1000; thin = 1;
##          total post-warmup samples = 4000
## 
## Population-Level Effects: 
##                                   Estimate Est.Error l-95% CI u-95% CI Rhat Bulk_ESS Tail_ESS
## govactz_Intercept                     0.01      0.03    -0.05     0.06 1.00     4481     3111
## negemotzmissing_Intercept            -0.00      0.04    -0.07     0.07 1.00     5626     3056
## govactz_age_z                        -0.06      0.03    -0.12    -0.00 1.00     5297     3082
## govactz_minegemot_z_missing           0.57      0.03     0.51     0.63 1.00     4145     2859
## govactz_minegemot_z_missing:age_z     0.13      0.03     0.07     0.19 1.00     5121     2854
## 
## Family Specific Parameters: 
##                       Estimate Est.Error l-95% CI u-95% CI Rhat Bulk_ESS Tail_ESS
## sigma_govactz             0.81      0.02     0.77     0.85 1.00     5050     3021
## sigma_negemotzmissing     1.00      0.03     0.95     1.05 1.00     4670     2570
## 
## Samples were drawn using sampling(NUTS). For each parameter, Bulk_ESS
## and Tail_ESS are effective sample size measures, and Rhat is the potential
## scale reduction factor on split chains (at convergence, Rhat = 1).
```

When using the multivariate `mi()` syntax, your `print()` output becomes more complicated. We got regression sub-models for both `govact_z` and `negemot_z_missing`. But look at the line at the top of the output that reads "Data: glbwarm (Number of observations: 815)". The multivariate `mi()` syntax used all the available data. No listwise deletion necessary.

The `print()` output for our model obscured some of the results. To clarify what the `mi()` syntax did, let's peek at the first columns returned by `posterior_samples()`.


```r
post <- posterior_samples(model9.9)

post[, 1:20] %>% 
  glimpse()
```

```
## Rows: 4,000
## Columns: 20
## $ b_govactz_Intercept                     <dbl> 0.0749275070, 0.0236605275, 0.0171695143, 0.0273169817,…
## $ b_negemotzmissing_Intercept             <dbl> -2.932031e-02, -5.729402e-02, 9.342923e-03, -1.672143e-…
## $ b_govactz_age_z                         <dbl> -0.121048656, -0.039921637, -0.056409711, -0.068838248,…
## $ bsp_govactz_minegemot_z_missing         <dbl> 0.5546730, 0.5218849, 0.5792408, 0.5801358, 0.6039476, …
## $ `bsp_govactz_minegemot_z_missing:age_z` <dbl> 0.11250534, 0.12458837, 0.16013499, 0.09081226, 0.17704…
## $ sigma_govactz                           <dbl> 0.7896917, 0.8086709, 0.8292742, 0.7877481, 0.7723515, …
## $ sigma_negemotzmissing                   <dbl> 0.9789380, 0.9449948, 1.0223828, 0.9916485, 0.9760478, …
## $ `Ymi_negemotzmissing[10]`               <dbl> -1.76086628, -0.60011782, -0.94751260, -0.73819220, -1.…
## $ `Ymi_negemotzmissing[18]`               <dbl> -1.28452600, -0.32702552, -0.35116881, -1.30556557, 0.6…
## $ `Ymi_negemotzmissing[26]`               <dbl> 1.54970098, 0.93366234, 0.58695905, 0.13467324, 0.04171…
## $ `Ymi_negemotzmissing[29]`               <dbl> -0.2306218, -0.1084225, -0.9775966, 1.6341533, 1.639533…
## $ `Ymi_negemotzmissing[32]`               <dbl> 0.25325707, -0.29865875, -0.76514861, -0.05351152, -0.2…
## $ `Ymi_negemotzmissing[34]`               <dbl> 1.666838566, -0.120717236, 1.809119891, -1.090401692, -…
## $ `Ymi_negemotzmissing[38]`               <dbl> -2.08630746, -0.68504610, -1.67724458, -1.30654853, -1.…
## $ `Ymi_negemotzmissing[41]`               <dbl> 0.78337889, 0.34046977, 0.20056447, 0.84667202, 0.95903…
## $ `Ymi_negemotzmissing[50]`               <dbl> -1.73376284, -1.14144278, 0.02349012, -0.16918008, 0.17…
## $ `Ymi_negemotzmissing[51]`               <dbl> -0.870653748, -0.827500997, -1.321103595, 0.392443024, …
## $ `Ymi_negemotzmissing[56]`               <dbl> -0.53992302, -0.97511516, 0.93447738, -0.57373868, 0.50…
## $ `Ymi_negemotzmissing[78]`               <dbl> 0.35157182, 1.06523252, -1.73324156, 1.19414852, -1.241…
## $ `Ymi_negemotzmissing[89]`               <dbl> -0.18948789, -1.74292500, -0.49641526, -0.75521725, -0.…
```

Columns `b_govactz_Intercept` through `sigma_negemotzmissing` were business as usual. But notice all the `Ymi_negemotzmissing[i]` columns. In each of these we see 4,000 posterior draws for the missing `negemot_z_missing` values. The `[i]` part of the column names indexes which row number the iterations correspond to. Summarizing these columns might help us get a sense of the results.


```r
library(tidybayes)

post %>% 
  pivot_longer(starts_with("Ymi"),
               names_to = "row") %>% 
  group_by(row) %>% 
  # yep, that's right, we're summarizing as usual
  mean_qi(value) %>% 
  mutate_if(is.double, round, digits = 2) %>%
  select(row:.upper)
```

```
## # A tibble: 84 x 4
##    row                      value .lower .upper
##    <chr>                    <dbl>  <dbl>  <dbl>
##  1 Ymi_negemotzmissing[10]  -0.88  -2.39   0.6 
##  2 Ymi_negemotzmissing[101]  0.15  -1.56   1.86
##  3 Ymi_negemotzmissing[117] -0.17  -1.83   1.49
##  4 Ymi_negemotzmissing[135]  0.26  -1.29   1.83
##  5 Ymi_negemotzmissing[139] -0.32  -1.93   1.27
##  6 Ymi_negemotzmissing[148] -1.4   -2.88   0.06
##  7 Ymi_negemotzmissing[150] -0.3   -1.74   1.17
##  8 Ymi_negemotzmissing[152]  0.01  -1.56   1.6 
##  9 Ymi_negemotzmissing[153] -1.58  -3.09  -0.08
## 10 Ymi_negemotzmissing[154]  0.59  -0.83   2.07
## 11 Ymi_negemotzmissing[162]  0.09  -1.51   1.66
## 12 Ymi_negemotzmissing[164]  0.38  -1.14   1.89
## 13 Ymi_negemotzmissing[166] -0.05  -1.58   1.44
## 14 Ymi_negemotzmissing[167] -0.15  -1.61   1.33
## 15 Ymi_negemotzmissing[178] -0.51  -1.97   0.92
## 16 Ymi_negemotzmissing[18]  -0.87  -2.32   0.6 
## 17 Ymi_negemotzmissing[186]  0.11  -1.42   1.62
## 18 Ymi_negemotzmissing[214]  0.95  -0.51   2.39
## 19 Ymi_negemotzmissing[230] -0.18  -1.85   1.54
## 20 Ymi_negemotzmissing[246]  0.6   -1.14   2.39
## 21 Ymi_negemotzmissing[259] -0.99  -2.74   0.77
## 22 Ymi_negemotzmissing[26]   0.61  -0.82   2.06
## 23 Ymi_negemotzmissing[260]  0.5   -0.99   1.99
## 24 Ymi_negemotzmissing[266]  0.25  -1.17   1.62
## 25 Ymi_negemotzmissing[284]  0.15  -1.67   1.97
## 26 Ymi_negemotzmissing[29]   0.29  -1.19   1.8 
## 27 Ymi_negemotzmissing[32]  -0.48  -2.13   1.14
## 28 Ymi_negemotzmissing[329]  0.23  -1.52   1.93
## 29 Ymi_negemotzmissing[337]  0.26  -1.56   2.1 
## 30 Ymi_negemotzmissing[338]  0.17  -1.63   1.99
## 31 Ymi_negemotzmissing[34]   0.28  -1.32   1.9 
## 32 Ymi_negemotzmissing[350] -0.92  -2.6    0.81
## 33 Ymi_negemotzmissing[358]  0.95  -0.74   2.68
## 34 Ymi_negemotzmissing[371]  0.13  -1.31   1.57
## 35 Ymi_negemotzmissing[38]  -1.59  -3.02  -0.17
## 36 Ymi_negemotzmissing[383]  0.44  -1.11   1.98
## 37 Ymi_negemotzmissing[394]  0.75  -0.87   2.42
## 38 Ymi_negemotzmissing[397]  0.32  -1.46   2.07
## 39 Ymi_negemotzmissing[398]  0.57  -1.01   2.17
## 40 Ymi_negemotzmissing[401] -0.26  -1.9    1.38
## 41 Ymi_negemotzmissing[406]  0.62  -1.01   2.2 
## 42 Ymi_negemotzmissing[41]   0.6   -1.02   2.16
## 43 Ymi_negemotzmissing[424]  0.68  -1.05   2.37
## 44 Ymi_negemotzmissing[435] -0.11  -1.9    1.71
## 45 Ymi_negemotzmissing[440]  0.35  -1.26   1.92
## 46 Ymi_negemotzmissing[447] -0.16  -1.74   1.41
## 47 Ymi_negemotzmissing[469] -0.03  -1.79   1.69
## 48 Ymi_negemotzmissing[472]  0.41  -1.08   1.94
## 49 Ymi_negemotzmissing[476]  0.67  -0.8    2.14
## 50 Ymi_negemotzmissing[484] -1.4   -2.96   0.09
## 51 Ymi_negemotzmissing[50]  -0.2   -1.63   1.19
## 52 Ymi_negemotzmissing[507] -0.16  -1.73   1.42
## 53 Ymi_negemotzmissing[51]  -0.52  -2      0.97
## 54 Ymi_negemotzmissing[515]  0.23  -1.26   1.77
## 55 Ymi_negemotzmissing[519] -0.06  -1.57   1.46
## 56 Ymi_negemotzmissing[524] -0.32  -1.87   1.2 
## 57 Ymi_negemotzmissing[540]  0.47  -1.18   2.13
## 58 Ymi_negemotzmissing[555]  0.46  -1.14   2.08
## 59 Ymi_negemotzmissing[56]   0     -1.64   1.61
## 60 Ymi_negemotzmissing[585]  0.04  -1.39   1.48
## 61 Ymi_negemotzmissing[593]  0.13  -1.64   1.89
## 62 Ymi_negemotzmissing[602] -0.59  -2.05   0.84
## 63 Ymi_negemotzmissing[605]  0.75  -0.91   2.36
## 64 Ymi_negemotzmissing[612]  0.14  -1.54   1.88
## 65 Ymi_negemotzmissing[613]  0.69  -0.96   2.37
## 66 Ymi_negemotzmissing[621] -0.76  -2.19   0.67
## 67 Ymi_negemotzmissing[629]  0.12  -1.39   1.63
## 68 Ymi_negemotzmissing[630]  0.4   -1.07   1.89
## 69 Ymi_negemotzmissing[643]  0.88  -0.89   2.61
## 70 Ymi_negemotzmissing[653] -0.61  -2.29   1.13
## 71 Ymi_negemotzmissing[679] -0.92  -2.6    0.74
## 72 Ymi_negemotzmissing[701] -0.17  -1.75   1.41
## 73 Ymi_negemotzmissing[742]  0.23  -1.33   1.81
## 74 Ymi_negemotzmissing[751]  0.32  -1.32   1.96
## 75 Ymi_negemotzmissing[752] -0.85  -2.26   0.57
## 76 Ymi_negemotzmissing[760]  0.44  -1.26   2.06
## 77 Ymi_negemotzmissing[774]  0.82  -0.96   2.6 
## 78 Ymi_negemotzmissing[779] -0.03  -1.73   1.68
## 79 Ymi_negemotzmissing[78]   0.14  -1.53   1.89
## 80 Ymi_negemotzmissing[792] -0.11  -1.91   1.71
## 81 Ymi_negemotzmissing[794]  0.29  -1.43   2.03
## 82 Ymi_negemotzmissing[799] -0.17  -1.89   1.47
## 83 Ymi_negemotzmissing[89]  -0.77  -2.32   0.84
## 84 Ymi_negemotzmissing[94]   0.28  -1.28   1.81
```

That's a lot of output. Here's what those summaries look like in a coefficient plot.


```r
# summarize just like before
post %>% 
   pivot_longer(starts_with("Ymi"),
                names_to = "row") %>% 
  group_by(row) %>% 
  mean_qi(value) %>% 
  
  # plot!
  ggplot(aes(x = row, y = value, ymin = .lower, ymax = .upper)) +
  geom_hline(yintercept = 0, color = "grey75") +
  geom_pointinterval(size = 1/3) +
  scale_x_discrete("rank-ordered row number", breaks = NULL) +
  ylab("imputed value") +
  theme_xkcd()
```

<img src="09_files/figure-html/unnamed-chunk-37-1.png" width="576" />

Each missing `negemot_z` value got an entire posterior distribution. And just as the model is uncertain about what those values might have been, that uncertainty was baked right into the primary submodel predicting `govact_z`. That's a good thing. We want our Bayesian models to use as much information as they can and yield results with as much certainty as possible. But we don't want our models to be more certain than the data--and priors--allow. When you use listwise deletion methods, you leave information on the table, which we don't want. But when you use old fashioned ad hock methods like mean imputation, you underestimate the uncertainty in the model, which we also don't want. We want the middle path.

Here's a focused look at two other important new parameters.


```r
posterior_summary(model9.9)[c("b_negemotzmissing_Intercept", "sigma_negemotzmissing"),] %>% 
  round(digits = 3)
```

```
##                             Estimate Est.Error   Q2.5 Q97.5
## b_negemotzmissing_Intercept    0.000     0.036 -0.071 0.072
## sigma_negemotzmissing          0.997     0.027  0.947 1.052
```

Our model has estimated the mean and standard deviations for our `negemot_z_missing` variable. Hopefully that isn't a surprise. This is exactly what we asked **brms** to do with the `negemot_z_missing | mi() ~ 1` part of the model formula. Since that submodel had no predictors, the intercept was just the mean. Correspondingly, the residual variance was the entire variance--but expressed in the usual $\sigma$ metric since we're using **brms**. And since our `negemot_z_missing` variable is a subset of the standardized `negemot_z` variable, naturally the estimates for the mean and standard deviation are about 0 and 1, respectively.

Another method we could have used is multiple imputation. With multiple imputation, you create a small number of alternative data sets, typically 5, into which you impute plausible values into the missing value slots. You then fit the model separately for each of the imputed data sets. Because the imputed values will vary across the data sets, that uncertainty will get appropriately transmitted to the model. I know this might sound crazy, but it typically leads to much lower model bias when compared to mean imputation or listwise deletion.

But we didn't quite use multiple imputation. With one-step Bayesian imputation using the `mi()` syntax, you get an entire posterior distribution for each missing value. And if you have variables in the data set that might help predict what those missing values are, you'd just plug that into the missing data submodel. Improving the imputation model can improve the subsequent substantive model.

For more on the `mi()` approach, see Bürkner's [-@Bürkner2021HandleMissingValues] [vignette](https://CRAN.R-project.org/package=brms/vignettes/brms_missings.html). McElreath lectured on this topic ([here](https://www.youtube.com/watch?v=Yi0EqAu043A) and [here](https://www.youtube.com/watch?v=UgLF0aLk85s)) within the context of his *Statistical rethinking* texts [@mcelreathStatisticalRethinkingBayesian2015; @mcelreathStatisticalRethinkingBayesian2020], and you can find links to my translations of both of his texts [here](https://solomonkurz.netlify.app/bookdown/). For a more general introduction to missing data theory, check out van Burren's [-@vanbuurenFlexibleImputationMissing2018] book, [*Flexible imputation of missing data*](https://stefvanbuuren.name/fimd/), or Enders' great [-@enders2010applied] text, [*Applied missing data analysis*](http://www.appliedmissingdata.com). You can also find Enders lecturing on missing data [here](https://vimeo.com/147353266).

The take home message is there is no need to ignore missing data or use outdated procedures like listwise deletion. Be a champion and model your missing data with **brms**.

## More than one moderator

None of this is a problem for **brms**. But instead of using the `model=i` syntax in Hayes's PROCESS, you just have to specify your model formula in `brm()`.

### Additive multiple moderation.

It's trivial to add `sex`, its interaction with `negemot`, and the two covariates (i.e., `posemot` and `ideology`) to the model. We can even do it within `update()`.


```r
model9.10 <- 
  update(model9.1, 
         newdata = glbwarm,
         govact ~ 1 + negemot + sex + age + posemot + ideology + negemot:sex + negemot:age,
         cores = 4,
         file = "fits/model09.10")
```

Our output matches nicely with the formula at the bottom of page 232 and the PROCESS output in Figure 9.2. 


```r
print(model9.10, digits = 3)
```

```
##  Family: gaussian 
##   Links: mu = identity; sigma = identity 
## Formula: govact ~ negemot + sex + age + posemot + ideology + negemot:sex + negemot:age 
##    Data: glbwarm (Number of observations: 815) 
## Samples: 4 chains, each with iter = 2000; warmup = 1000; thin = 1;
##          total post-warmup samples = 4000
## 
## Population-Level Effects: 
##             Estimate Est.Error l-95% CI u-95% CI  Rhat Bulk_ESS Tail_ESS
## Intercept      5.269     0.339    4.628    5.907 1.000     2391     2381
## negemot        0.094     0.083   -0.067    0.253 1.001     2126     2284
## sex           -0.739     0.195   -1.127   -0.364 1.002     2216     2183
## age           -0.018     0.006   -0.030   -0.006 1.001     2096     2356
## posemot       -0.024     0.029   -0.080    0.033 1.001     3667     2516
## ideology      -0.206     0.027   -0.259   -0.154 1.000     3792     2591
## negemot:sex    0.203     0.051    0.108    0.304 1.001     2238     2323
## negemot:age    0.005     0.002    0.002    0.008 1.001     2050     2206
## 
## Family Specific Parameters: 
##       Estimate Est.Error l-95% CI u-95% CI  Rhat Bulk_ESS Tail_ESS
## sigma    1.047     0.027    0.996    1.101 1.001     4076     2866
## 
## Samples were drawn using sampling(NUTS). For each parameter, Bulk_ESS
## and Tail_ESS are effective sample size measures, and Rhat is the potential
## scale reduction factor on split chains (at convergence, Rhat = 1).
```

On page 325, Hayes discussed the unique variance each of the two moderation terms accounted for after controlling for the other covariates. In order to get our Bayesian version of these, we'll have to fit two additional models, one after removing each of the interaction terms.


```r
model9.11 <- 
  update(model9.10, 
         newdata = glbwarm,
         govact ~ 1 + negemot + sex + age + posemot + ideology + negemot:sex,
         cores = 4,
         file = "fits/model09.11")

model9.12 <- 
  update(model9.10, 
         newdata = glbwarm,
         govact ~ 1 + negemot + sex + age + posemot + ideology + negemot:age,
         cores = 4,
         file = "fits/model09.12")
```

Here we'll extract the `bayes_R2()` iterations for each of the three models, place them all in a single tibble, and then do a little arithmetic to get the difference scores. After all that data wrangling, we'll `summarize()` as usual.



```r
r2 <-
  tibble(r2_without_age_interaction = bayes_R2(model9.11, summary = F)[, 1],
         r2_without_sex_interaction = bayes_R2(model9.12, summary = F)[, 1],
         r2_with_both_interactions  = bayes_R2(model9.10, summary = F)[, 1]) %>% 
  mutate(`delta R2 due to age interaction` = r2_with_both_interactions - r2_without_age_interaction,
         `delta R2 due to sex interaction` = r2_with_both_interactions - r2_without_sex_interaction)

r2 %>% 
  pivot_longer(`delta R2 due to age interaction`:`delta R2 due to sex interaction`) %>% 
  group_by(name) %>% 
  mean_qi(value) %>% 
  mutate_if(is.double, round, digits = 3)
```

```
## # A tibble: 2 x 7
##   name                            value .lower .upper .width .point .interval
##   <chr>                           <dbl>  <dbl>  <dbl>  <dbl> <chr>  <chr>    
## 1 delta R2 due to age interaction 0.006 -0.048  0.06    0.95 mean   qi       
## 2 delta R2 due to sex interaction 0.012 -0.044  0.067   0.95 mean   qi
```

Recall that $R^2$ is in a 0-to-1 metric. It's a proportion. If you want to convert that to a percentage, as in percent of variance explained, you'd just multiply by 100. To make it explicit, let's do that.


```r
r2 %>% 
  pivot_longer(`delta R2 due to age interaction`:`delta R2 due to sex interaction`) %>% 
  group_by(name) %>%
  mutate(percent = value * 100) %>% 
  mean_qi(percent) %>% 
  mutate_if(is.double, round, digits = 3)
```

```
## # A tibble: 2 x 7
##   name                            percent .lower .upper .width .point .interval
##   <chr>                             <dbl>  <dbl>  <dbl>  <dbl> <chr>  <chr>    
## 1 delta R2 due to age interaction   0.615  -4.82   6.00   0.95 mean   qi       
## 2 delta R2 due to sex interaction   1.17   -4.38   6.74   0.95 mean   qi
```

Hopefully it's clear how our proportions turned percentages correspond to the numbers on page 325. However, note how our 95% credible intervals do not cohere with the $p$-values from Hayes's $F$-tests.

If we want to prep for our version of Figure 9.3, we'll need to carefully specify the predictor values we'll pass through the `fitted()` function. Here we do so and save them in `nd`.


```r
nd <-
  crossing(negemot = seq(from = .5, to = 6.5, length.out = 30),
           sex     = 0:1) %>% 
  expand(nesting(negemot, sex),
         age = c(30, 50, 70)) %>% 
  mutate(posemot  = mean(glbwarm$posemot),
         ideology = mean(glbwarm$ideology))

str(nd)
```

```
## tibble [180 × 5] (S3: tbl_df/tbl/data.frame)
##  $ negemot : num [1:180] 0.5 0.5 0.5 0.5 0.5 ...
##  $ sex     : int [1:180] 0 0 0 1 1 1 0 0 0 1 ...
##  $ age     : num [1:180] 30 50 70 30 50 70 30 50 70 30 ...
##  $ posemot : num [1:180] 3.13 3.13 3.13 3.13 3.13 ...
##  $ ideology: num [1:180] 4.08 4.08 4.08 4.08 4.08 ...
```

With our `nd` values in hand, we're ready to make our version of Figure 9.3.


```r
fitted(model9.10, newdata = nd) %>% 
  data.frame() %>% 
  bind_cols(nd) %>% 
  # these lines will make the strip text match with those with Hayes's Figure
  mutate(sex = if_else(sex == 0, str_c("Females, W = ", sex),
                       str_c("Males, W = ", sex)),
         age = str_c("Age, Z, = ", age)) %>% 

  # finally, we plot!
  ggplot(aes(x = negemot, group = sex)) +
  geom_ribbon(aes(ymin = Q2.5, ymax = Q97.5, fill = sex),
              alpha = 1/3, color = "transparent") +
  geom_line(aes(y = Estimate, color = sex),
            size = 1) +
  scale_x_continuous(breaks = 1:6) +
  coord_cartesian(xlim = c(1, 6),
                  ylim = c(3, 6)) +
  labs(x = expression("Negative Emotions about Climate Change, "*italic(X)),
       y = expression("Support for Government Action to Mitigate Climate Change, "*italic(Y))) +
  theme_xkcd() +
  theme(legend.position = "top",
        legend.title = element_blank()) +
  facet_grid(age ~ .)
```

<img src="09_files/figure-html/unnamed-chunk-43-1.png" width="576" />

Recall that the conditional effect of $X$ for various values of $W$ and $Z$ is

$$\theta_{X \rightarrow Y} = b_1 + b_4 W + b_5 Z.$$

In the terms of `model9.10` where `sex` = $W$ and `age` = $Z$, we can restate that as

$$
\theta_{\text{negemot} \rightarrow \text{govact}} = 
b_\text{negemot} + 
b_{\text{negemot} \times \text{sex}} \text{sex} + 
b_{\text{negemot} \times \text{age}} \text{age}.
$$

This is easiest to show with `posterior_samples()` and a little algebra. As in the middle of page 329, here we solve for both sexes and `age == 50`.


```r
post <- posterior_samples(model9.10)

post %>% 
  # algebra
  mutate(men   = b_negemot + `b_negemot:sex` * 1 + `b_negemot:age` * 50,
         women = b_negemot + `b_negemot:sex` * 0 + `b_negemot:age` * 50) %>% 
  # more algebra
  mutate(`men - women` = men - women) %>% 
  pivot_longer(men:`men - women`) %>% 
  # this just orders the output
  mutate(name = factor(name, levels = c("men", "women", "men - women"))) %>% 
  group_by(name) %>% 
  mean_qi(value) %>% 
  mutate_if(is.double, round, digits = 3)
```

```
## # A tibble: 3 x 7
##   name        value .lower .upper .width .point .interval
##   <fct>       <dbl>  <dbl>  <dbl>  <dbl> <chr>  <chr>    
## 1 men         0.534  0.466  0.605   0.95 mean   qi       
## 2 women       0.331  0.259  0.401   0.95 mean   qi       
## 3 men - women 0.203  0.108  0.304   0.95 mean   qi
```

Switching our discussion to $b_5$ (i.e., $b_{\text{negemot} \times \text{age}}$), Hayes showed its value for two groups 10 years apart. Here it is for `model9.10`.


```r
post %>% 
  # algebra
  transmute(`10 * b_5`   = `b_negemot:age` * 10) %>% 
  mean_qi() %>% 
  mutate_if(is.double, round, digits = 3)
```

```
## # A tibble: 1 x 6
##   `10 * b_5` .lower .upper .width .point .interval
##        <dbl>  <dbl>  <dbl>  <dbl> <chr>  <chr>    
## 1      0.047  0.017  0.078   0.95 mean   qi
```

Further down on page 329, Hayes solved for the conditional effect of `negemot` for women at 50 versus 30.


```r
post %>% 
  mutate(women_50 = b_negemot + `b_negemot:sex` * 0 + `b_negemot:age` * 50,
         women_30 = b_negemot + `b_negemot:sex` * 0 + `b_negemot:age` * 30) %>% 
  mutate(`women_50 - women_30` = women_50 - women_30) %>% 
  pivot_longer(women_50:`women_50 - women_30`) %>% 
  mutate(name = factor(name, levels = c("women_50", "women_30", "women_50 - women_30"))) %>% 
  group_by(name) %>% 
  mean_qi(value) %>% 
  mutate_if(is.double, round, digits = 3)
```

```
## # A tibble: 3 x 7
##   name                value .lower .upper .width .point .interval
##   <fct>               <dbl>  <dbl>  <dbl>  <dbl> <chr>  <chr>    
## 1 women_50            0.331  0.259  0.401   0.95 mean   qi       
## 2 women_30            0.236  0.148  0.321   0.95 mean   qi       
## 3 women_50 - women_30 0.095  0.033  0.157   0.95 mean   qi
```

Here it is for men.


```r
post %>% 
  mutate(men_50 = b_negemot + `b_negemot:sex` * 1 + `b_negemot:age` * 50,
         men_30 = b_negemot + `b_negemot:sex` * 1 + `b_negemot:age` * 30) %>% 
  mutate(`men_50 - men_30` = men_50 - men_30) %>% 
  pivot_longer(men_50:`men_50 - men_30`) %>% 
  mutate(name = factor(name, levels = c("men_50", "men_30", "men_50 - men_30"))) %>% 
  group_by(name) %>% 
  mean_qi(value) %>% 
  mutate_if(is.double, round, digits = 3)
```

```
## # A tibble: 3 x 7
##   name            value .lower .upper .width .point .interval
##   <fct>           <dbl>  <dbl>  <dbl>  <dbl> <chr>  <chr>    
## 1 men_50          0.534  0.466  0.605   0.95 mean   qi       
## 2 men_30          0.439  0.34   0.542   0.95 mean   qi       
## 3 men_50 - men_30 0.095  0.033  0.157   0.95 mean   qi
```

If you look closely, you'll see `women_50 - women_30` is the same as `men_50 - men_30`.

### Moderated moderation.

To fit the moderated moderation model in **brms**, just add to two new interaction terms to the `formula`.


```r
model9.13 <- 
  update(model9.10, 
         newdata = glbwarm,
         govact ~ 1 + negemot + sex + age + posemot + ideology + 
           negemot:sex + negemot:age + sex:age + 
           negemot:sex:age,
         cores = 4,
         file = "fits/model09.13")
```

Check the summary.


```r
print(model9.13, digits = 3)
```

```
##  Family: gaussian 
##   Links: mu = identity; sigma = identity 
## Formula: govact ~ negemot + sex + age + posemot + ideology + negemot:sex + negemot:age + sex:age + negemot:sex:age 
##    Data: glbwarm (Number of observations: 815) 
## Samples: 4 chains, each with iter = 2000; warmup = 1000; thin = 1;
##          total post-warmup samples = 4000
## 
## Population-Level Effects: 
##                 Estimate Est.Error l-95% CI u-95% CI  Rhat Bulk_ESS Tail_ESS
## Intercept          4.562     0.487    3.590    5.517 1.002     1107     1839
## negemot            0.273     0.120    0.036    0.509 1.003     1083     1359
## sex                0.522     0.654   -0.757    1.856 1.000      958     1352
## age               -0.003     0.010   -0.022    0.015 1.002     1049     1418
## posemot           -0.021     0.028   -0.076    0.032 1.000     3077     2955
## ideology          -0.206     0.027   -0.259   -0.153 1.000     3484     2435
## negemot:sex       -0.131     0.170   -0.477    0.206 1.000      967     1472
## negemot:age        0.001     0.002   -0.004    0.006 1.003     1051     1322
## sex:age           -0.025     0.012   -0.050   -0.001 1.000      935     1361
## negemot:sex:age    0.007     0.003    0.000    0.013 1.000      938     1311
## 
## Family Specific Parameters: 
##       Estimate Est.Error l-95% CI u-95% CI  Rhat Bulk_ESS Tail_ESS
## sigma    1.046     0.026    0.998    1.099 1.000     3203     2709
## 
## Samples were drawn using sampling(NUTS). For each parameter, Bulk_ESS
## and Tail_ESS are effective sample size measures, and Rhat is the potential
## scale reduction factor on split chains (at convergence, Rhat = 1).
```

Our `print()` output matches fairly well with the OLS results on pages 332 and 333. Here's our new Bayesian $R^2$.


```r
bayes_R2(model9.13) %>% round(digits = 3)
```

```
##    Estimate Est.Error  Q2.5 Q97.5
## R2    0.417      0.02 0.376 0.454
```

Because we haven't changed the predictor variables in the model--just added interactions among them--there's no need to redo our `nd` values. Rather, all we need to do is pass them through `fitted()` based on our new `model9.13` and plot. Without further ado, here's our Figure 9.6.


```r
fitted(model9.13, newdata = nd) %>% 
  data.frame() %>% 
  bind_cols(nd) %>% 
  # these lines will make the strip text match with those with Hayes's Figure
  mutate(sex = if_else(sex == 0, str_c("Females, W = ", sex),
                       str_c("Males, W = ", sex)),
         age = str_c("Age, Z, = ", age)) %>% 
  
  # behold, Figure 9.6!
  ggplot(aes(x = negemot, group = sex)) +
  geom_ribbon(aes(ymin = Q2.5, ymax = Q97.5, fill = sex),
              alpha = 1/3, color = "transparent") +
  geom_line(aes(y = Estimate, color = sex),
            size = 1) +
  scale_x_continuous(breaks = 1:6) +
  coord_cartesian(xlim = c(1, 6),
                  ylim = c(3, 6)) +
  labs(x = expression("Negative Emotions about Climate Change, "*italic(X)),
       y = expression("Support for Government Action to Mitigate Climate Change, "*italic(Y))) +
  theme_xkcd() +
  theme(legend.position = "top",
        legend.title = element_blank()) +
  facet_grid(age ~ .)
```

<img src="09_files/figure-html/unnamed-chunk-50-1.png" width="576" />

For the pick-a-point values Hayes covered on page 338, recall that when using `posterior_sample()`, our $b_4$ is `b_negemot:sex` and our $b_7$ is `b_negemot:sex:age`.


```r
post <- posterior_samples(model9.13)

post %>% 
  mutate(`age = 30` = `b_negemot:sex` + `b_negemot:sex:age` * 30, 
         `age = 50` = `b_negemot:sex` + `b_negemot:sex:age` * 50, 
         `age = 70` = `b_negemot:sex` + `b_negemot:sex:age` * 70) %>% 
  pivot_longer(contains("="), names_to = "theta_XW_on_Y_given") %>%
  group_by(theta_XW_on_Y_given) %>%
  mean_qi(value) %>% 
  mutate_if(is.double, round, digits = 3)
```

```
## # A tibble: 3 x 7
##   theta_XW_on_Y_given value .lower .upper .width .point .interval
##   <chr>               <dbl>  <dbl>  <dbl>  <dbl> <chr>  <chr>    
## 1 age = 30            0.07  -0.103  0.234   0.95 mean   qi       
## 2 age = 50            0.204  0.105  0.306   0.95 mean   qi       
## 3 age = 70            0.338  0.178  0.5     0.95 mean   qi
```

Our method for making a JN technique plot with `fitted()` way back in Chapter 7 isn't going to work, here. At least not as far as I can see. Rather, we're going to have to skillfully manipulate our `post` object. For those new to **R**, this might be a little confusing at first. So I'm going to make a crude attempt first and then get more sophisticated.

Crude attempt:


```r
post %>% 
  mutate(`age = 30` = `b_negemot:sex` + `b_negemot:sex:age` * 30, 
         `age = 50` = `b_negemot:sex` + `b_negemot:sex:age` * 50, 
         `age = 70` = `b_negemot:sex` + `b_negemot:sex:age` * 70) %>% 
  pivot_longer(contains("="), names_to = "theta_XW_on_Y_given") %>%
  mutate(`theta XW on Y given` = str_extract(theta_XW_on_Y_given, "\\d+") %>% as.double()) %>% 
  group_by(`theta XW on Y given`) %>%
  mean_qi(value) %>%
  
  # the plot
  ggplot(aes(x = `theta XW on Y given`)) +
  geom_hline(yintercept = 0) +
  geom_vline(xintercept = 38.114) +
  geom_ribbon(aes(ymin = .lower, ymax = .upper),
              alpha = 1/2) +
  geom_line(aes(y = value), 
            size = 1) +
  coord_cartesian(xlim = c(20, 85),
                  ylim = c(-.25, .75)) +
  theme_xkcd()
```

<img src="09_files/figure-html/unnamed-chunk-52-1.png" width="576" />

Notice how we just took the code from our pick-a-point analysis and dumped it into a plot. So one obvious approach would be to pick like 30 or 50 `age` values to plug into `transmute()` and just do the same thing. If you're super afraid of coding, that'd be one intuitive but extremely verbose attempt. I have done stuff like that earlier in my **R** career. There's no shame in being extremely verbose and redundant if that's what makes sense. Another way is to think in terms of functions. When we made `age = 30` within `transmute()`, we took a specific `age` value (i.e., 30) and plugged it into the formula `b_negemot:sex + b_negemot:sex:age * i` where $i$ = 30. And when we made `age = 50` we did exactly the same thing but switched out the 30 for a 50. So what we need is a function that will take a range of values for $i$, plug them into our `b_negemot:sex + b_negemot:sex:age * i` formula, and then neatly return the output. A nice base **R** function for that is `sapply()`.


```r
sapply(15:90, function(i) {
  post$`b_negemot:sex` + post$`b_negemot:sex:age` * i
}
) %>% 
  data.frame() %>% 
  str()
```

```
## 'data.frame':	4000 obs. of  76 variables:
##  $ X1 : num  -0.0525 -0.0842 0.1059 -0.063 0.0514 ...
##  $ X2 : num  -0.0452 -0.0772 0.1118 -0.0549 0.0577 ...
##  $ X3 : num  -0.0379 -0.0702 0.1177 -0.0469 0.0641 ...
##  $ X4 : num  -0.0307 -0.0632 0.1236 -0.0389 0.0705 ...
##  $ X5 : num  -0.0234 -0.0562 0.1295 -0.0308 0.0769 ...
##  $ X6 : num  -0.0161 -0.0492 0.1354 -0.0228 0.0833 ...
##  $ X7 : num  -0.00879 -0.04225 0.14129 -0.01474 0.08965 ...
##  $ X8 : num  -0.0015 -0.03527 0.1472 -0.00671 0.09603 ...
##  $ X9 : num  0.00578 -0.02828 0.1531 0.00133 0.10242 ...
##  $ X10: num  0.01307 -0.02129 0.159 0.00936 0.1088 ...
##  $ X11: num  0.0204 -0.0143 0.1649 0.0174 0.1152 ...
##  $ X12: num  0.02765 -0.00731 0.1708 0.02543 0.12156 ...
##  $ X13: num  0.03494 -0.00032 0.1767 0.03347 0.12794 ...
##  $ X14: num  0.04223 0.00667 0.1826 0.04151 0.13433 ...
##  $ X15: num  0.0495 0.0137 0.1885 0.0495 0.1407 ...
##  $ X16: num  0.0568 0.0206 0.1944 0.0576 0.1471 ...
##  $ X17: num  0.0641 0.0276 0.2003 0.0656 0.1535 ...
##  $ X18: num  0.0714 0.0346 0.2062 0.0737 0.1599 ...
##  $ X19: num  0.0787 0.0416 0.2121 0.0817 0.1662 ...
##  $ X20: num  0.086 0.0486 0.218 0.0897 0.1726 ...
##  $ X21: num  0.0932 0.0556 0.2239 0.0978 0.179 ...
##  $ X22: num  0.1005 0.0626 0.2298 0.1058 0.1854 ...
##  $ X23: num  0.1078 0.0696 0.2357 0.1138 0.1918 ...
##  $ X24: num  0.1151 0.0766 0.2416 0.1219 0.1981 ...
##  $ X25: num  0.1224 0.0836 0.2475 0.1299 0.2045 ...
##  $ X26: num  0.1297 0.0905 0.2534 0.1379 0.2109 ...
##  $ X27: num  0.137 0.0975 0.2593 0.146 0.2173 ...
##  $ X28: num  0.144 0.105 0.265 0.154 0.224 ...
##  $ X29: num  0.152 0.112 0.271 0.162 0.23 ...
##  $ X30: num  0.159 0.118 0.277 0.17 0.236 ...
##  $ X31: num  0.166 0.125 0.283 0.178 0.243 ...
##  $ X32: num  0.173 0.132 0.289 0.186 0.249 ...
##  $ X33: num  0.181 0.139 0.295 0.194 0.256 ...
##  $ X34: num  0.188 0.146 0.301 0.202 0.262 ...
##  $ X35: num  0.195 0.153 0.307 0.21 0.268 ...
##  $ X36: num  0.203 0.16 0.312 0.218 0.275 ...
##  $ X37: num  0.21 0.167 0.318 0.226 0.281 ...
##  $ X38: num  0.217 0.174 0.324 0.234 0.287 ...
##  $ X39: num  0.224 0.181 0.33 0.242 0.294 ...
##  $ X40: num  0.232 0.188 0.336 0.25 0.3 ...
##  $ X41: num  0.239 0.195 0.342 0.258 0.307 ...
##  $ X42: num  0.246 0.202 0.348 0.267 0.313 ...
##  $ X43: num  0.254 0.209 0.354 0.275 0.319 ...
##  $ X44: num  0.261 0.216 0.36 0.283 0.326 ...
##  $ X45: num  0.268 0.223 0.366 0.291 0.332 ...
##  $ X46: num  0.275 0.23 0.371 0.299 0.339 ...
##  $ X47: num  0.283 0.237 0.377 0.307 0.345 ...
##  $ X48: num  0.29 0.244 0.383 0.315 0.351 ...
##  $ X49: num  0.297 0.251 0.389 0.323 0.358 ...
##  $ X50: num  0.305 0.258 0.395 0.331 0.364 ...
##  $ X51: num  0.312 0.265 0.401 0.339 0.37 ...
##  $ X52: num  0.319 0.272 0.407 0.347 0.377 ...
##  $ X53: num  0.326 0.279 0.413 0.355 0.383 ...
##  $ X54: num  0.334 0.286 0.419 0.363 0.39 ...
##  $ X55: num  0.341 0.293 0.425 0.371 0.396 ...
##  $ X56: num  0.348 0.3 0.43 0.379 0.402 ...
##  $ X57: num  0.356 0.307 0.436 0.387 0.409 ...
##  $ X58: num  0.363 0.314 0.442 0.395 0.415 ...
##  $ X59: num  0.37 0.321 0.448 0.403 0.422 ...
##  $ X60: num  0.378 0.328 0.454 0.411 0.428 ...
##  $ X61: num  0.385 0.335 0.46 0.419 0.434 ...
##  $ X62: num  0.392 0.342 0.466 0.427 0.441 ...
##  $ X63: num  0.399 0.349 0.472 0.435 0.447 ...
##  $ X64: num  0.407 0.356 0.478 0.443 0.453 ...
##  $ X65: num  0.414 0.363 0.484 0.451 0.46 ...
##  $ X66: num  0.421 0.37 0.489 0.459 0.466 ...
##  $ X67: num  0.429 0.377 0.495 0.467 0.473 ...
##  $ X68: num  0.436 0.384 0.501 0.475 0.479 ...
##  $ X69: num  0.443 0.391 0.507 0.483 0.485 ...
##  $ X70: num  0.45 0.398 0.513 0.492 0.492 ...
##  $ X71: num  0.458 0.405 0.519 0.5 0.498 ...
##  $ X72: num  0.465 0.412 0.525 0.508 0.504 ...
##  $ X73: num  0.472 0.419 0.531 0.516 0.511 ...
##  $ X74: num  0.48 0.426 0.537 0.524 0.517 ...
##  $ X75: num  0.487 0.433 0.543 0.532 0.524 ...
##  $ X76: num  0.494 0.44 0.548 0.54 0.53 ...
```

Okay, so that looks a little monstrous. What we did in the first argument was tell `sapply()` which values we'd like to use in some function. We chose each integer ranging from 15 to 90--which, if you do the math, is 76 values. We then told `sapply()` to plug those values into a custom function, which we defined as `function(i) {post$b_negemot:sex + post$b_negemot:sex:age * i}`. In our custom function, `i` was a placeholder for each of those 76 integers. But remember that `post` has 4,000 rows, each one corresponding to one of the 4,000 posterior iterations. Thus, for each of our 76 `i`-values, we got 4,000 results. After all that `sapply()` returned a matrix. Since we like to work within the **tidyverse** and use **ggplot2**, we just went ahead and put those results in a tibble.

With our `sapply()` output in hand, all we need to do is a little more indexing and summarizing and we're ready to plot. The result is our very own version of Figure 9.7.


```r
sapply(15:90, function(i) post$`b_negemot:sex` + post$`b_negemot:sex:age` * i) %>% 
  data.frame() %>% 
  set_names(15:90) %>% 
  pivot_longer(everything()) %>% 
  mutate(age = as.double(name)) %>% 
  group_by(age) %>% 
  mean_qi(value) %>% 
  
  ggplot(aes(x = age)) +
  geom_hline(yintercept = 0, color = "grey75") +
  geom_vline(xintercept = 38.114, color = "grey75") +
  geom_ribbon(aes(ymin = .lower, ymax = .upper),
              alpha = 1/2) +
  geom_line(aes(y = value), 
            size = 1) +
  coord_cartesian(xlim = c(20, 85),
                  ylim = c(-.25, .75)) +
  labs(x = expression(paste("Age, ", italic(Z))),
       y = "Conditional Two-way Interaction Between\nNegative Emotions and Sex") +
  theme_xkcd()
```

<img src="09_files/figure-html/unnamed-chunk-54-1.png" width="576" />

Or for kicks and giggles, another way to get a clearer sense of how our data informed the shape of the plot, here we replace our `geom_ribbon() + geom_line()` code with `geom_pointrange()`.


```r
sapply(15:90, function(i) {
  post$`b_negemot:sex` + post$`b_negemot:sex:age` * i
}) %>% 
  data.frame() %>% 
  set_names(15:90) %>% 
  pivot_longer(everything()) %>% 
  mutate(age = as.double(name)) %>% 
  group_by(age) %>% 
  mean_qi(value) %>% 
  
  ggplot(aes(x = age)) +
  geom_hline(yintercept = 0, color = "grey75") +
  geom_vline(xintercept = 38.114, color = "grey75") +
  geom_pointrange(aes(y = value, ymin = .lower, ymax = .upper),
                  shape = 16, size = 1/3) +
  coord_cartesian(xlim = c(20, 85),
                  ylim = c(-.25, .75)) +
  labs(x = expression("Age, "*italic(Z)),
       y = "Conditional Two-way Interaction Between\nNegative Emotions and Sex") +
  theme_xkcd()
```

<img src="09_files/figure-html/unnamed-chunk-55-1.png" width="576" />

Although I probably wouldn't try to use a plot like this in a manuscript, I hope it makes clear how the way we've been implementing the JN technique is just the pick-a-point approach in bulk. No magic, here.

For all you **tidyverse** fanatics out there, don't worry. There are more **tidyverse**-centric ways to get the plot values than with `sapply()`. We'll get to them soon enough. It's advantageous to have good old base **R** `sapply()` up your sleeve, too. And new **R** users, it's helpful to know that `sapply()` is one part of the `apply()` family of base **R** functions, which you might learn more about [here](https://www.r-{bloggers.com}r-tutorial-on-the-apply-family-of-functions/) or [here](http://www.dummies.com/programming/r/how-to-use-the-apply-family-of-functions-in-r/) or [here](https://nsaunders.wordpress.com/2010/08/20/a-brief-introduction-to-apply-in-r/).

Now the conditional effect of $X$ on $Y$ given $W$ and $Z$ is

$$\theta_{X \rightarrow Y} = b_1 + b_4 W + b_5 Z + b_7 WZ.$$

In the terms of `model9.13` where `sex` = $W$ and `age` = $Z$, we can restate that as

$$
\theta_{\text{negemot} \rightarrow \text{govact}} = 
b_\text{negemot} + 
b_{\text{negemot} \times \text{sex}} \text{sex} + 
b_{\text{negemot} \times \text{age}} \text{age} + 
b_{\text{negemot} \times \text{sex} \times \text{age}} \text{sex} \times \text{age}.
$$

Following Hayes at the bottom of page 341, here is the difference in the effect of negative emotions between men and women among 30 year olds, $\theta_{XW \rightarrow Y} | (Z = 30)$.


```r
post %>% 
  # algebra
  mutate(men   = b_negemot + `b_negemot:sex` * 1 + `b_negemot:age` * 30 + `b_negemot:sex:age` * 1 * 30,
         women = b_negemot + `b_negemot:sex` * 0 + `b_negemot:age` * 30 + `b_negemot:sex:age` * 0 * 30) %>% 
  # more algebra
  mutate(`men - women` = men - women) %>% 
  pivot_longer(men:`men - women`) %>% 
  # this just orders the output
  mutate(name = factor(name, levels = c("men", "women", "men - women"))) %>% 
  group_by(name) %>% 
  mean_qi(value) %>% 
  mutate_if(is.double, round, digits = 3)
```

```
## # A tibble: 3 x 7
##   name        value .lower .upper .width .point .interval
##   <fct>       <dbl>  <dbl>  <dbl>  <dbl> <chr>  <chr>    
## 1 men          0.37  0.244  0.494   0.95 mean   qi       
## 2 women        0.3   0.193  0.411   0.95 mean   qi       
## 3 men - women  0.07 -0.103  0.234   0.95 mean   qi
```

In contrast, here is $\theta_{XW \rightarrow Y} | (Z = 50)$.


```r
post %>% 
  mutate(men   = b_negemot + `b_negemot:sex` * 1 + `b_negemot:age` * 50 + `b_negemot:sex:age` * 1 * 50,
         women = b_negemot + `b_negemot:sex` * 0 + `b_negemot:age` * 50 + `b_negemot:sex:age` * 0 * 50) %>% 
  mutate(`men - women` = men - women) %>% 
  pivot_longer(men:`men - women`) %>% 
  mutate(name = factor(name, levels = c("men", "women", "men - women"))) %>% 
  group_by(name) %>% 
  mean_qi(value) %>% 
  mutate_if(is.double, round, digits = 3)
```

```
## # A tibble: 3 x 7
##   name        value .lower .upper .width .point .interval
##   <fct>       <dbl>  <dbl>  <dbl>  <dbl> <chr>  <chr>    
## 1 men         0.522  0.45   0.592   0.95 mean   qi       
## 2 women       0.318  0.243  0.392   0.95 mean   qi       
## 3 men - women 0.204  0.105  0.306   0.95 mean   qi
```

Finally, here we compute $\theta_{XW \rightarrow Y} | (Z = 70)$.


```r
post %>% 
  transmute(men   = b_negemot + `b_negemot:sex` * 1 + `b_negemot:age` * 70 + `b_negemot:sex:age` * 1 * 70,
            women = b_negemot + `b_negemot:sex` * 0 + `b_negemot:age` * 70 + `b_negemot:sex:age` * 0 * 70) %>% 
  mutate(`men - women` = men - women) %>% 
  pivot_longer(men:`men - women`) %>% 
  mutate(name = factor(name, levels = c("men", "women", "men - women"))) %>% 
  group_by(name) %>% 
  mean_qi(value) %>% 
  mutate_if(is.double, round, digits = 3)
```

```
## # A tibble: 3 x 7
##   name        value .lower .upper .width .point .interval
##   <fct>       <dbl>  <dbl>  <dbl>  <dbl> <chr>  <chr>    
## 1 men         0.673  0.581  0.766   0.95 mean   qi       
## 2 women       0.336  0.207  0.473   0.95 mean   qi       
## 3 men - women 0.338  0.178  0.5     0.95 mean   qi
```

## Comparing conditional effects

> In this section, [Hayes discussed] a test of the difference between two conditional effects in a moderation model. The method [Hayes described] is called a "slope difference test" by Dawson [@dawsonModerationManagementResearch2014; @dawsonProbingThreewayInteractions2006], who offers some guidelines on how to conduct this test for the moderated moderation model. (p. 342)

As usual, we will follow along, but with alternative methods to the statistical testing paradigm. We will steadfastly continue summarizing and plotting the posterior distribution from various vantage points.

### Comparing conditional effects in the additive multiple moderation model.

When we're interested in estimating the difference in the conditional effec of $X$ on $Y$ (i.e., $\theta_{X \rightarrow Y}$) for $W = w_1$ and $Z = z_1$ versus when $W = w_2$ and $Z = z_2$, that follows the formula

\begin{align*}
\Delta \theta_{X \rightarrow Y} & = (b_1 + b_4 w_1 + b_5 z_1) - (b_1 + b_4 w_2 + b_5 z_2) \\
                                & = b_4 (w_1 - w_2) + b_5 (z_1 - z_2).
\end{align*}

As in other cases, we don't have to worry about special considerations for computing the standard errors for out Bayesian models. All we need to do is follow the simple algebraic manipulations of the posterior distribution. Because of the correlation structure within the parameters, the uncertainty in the conditional distribution will work itself out.

### Comparing conditional effects in the moderated moderation model.

We'll update our formula from last section to

\begin{align*}
\Delta \theta_{X \rightarrow Y} & = (b_1 + b_4 w_1 + b_5 z_1 + b_7 w_1 z_1) - (b_1 + b_4 w_2 + b_5 z_2 + b_7 w_2 z_2) \\
                                & = b_4 (w_1 - w_2) + b_5 (z_1 - z_2) + b_7 (w_1 z_1 - w_2 z_2).
\end{align*}

### Implementation in ~~PROCESS~~ brms.

Since we don't have the `contrast` feature automated like in PROCESS, we'll have to carefully follow the equations above to specify the values properly in **R**. Here we'll use the equation in the first line,

$$\Delta \theta_{X \rightarrow Y} = (b_1 + b_4 w_1 + b_5 z_1 + b_7 w_1 z_1) - (b_1 + b_4 w_2 + b_5 z_2 + b_7 w_2 z_2).$$


```r
w1 <- 1
z1 <- 30
w2 <- 0
z2 <- 50

post %>% 
  mutate(`30-year-old men`   = b_negemot + `b_negemot:sex` * w1 + `b_negemot:age` * z1 + `b_negemot:sex:age` * w1 * z1, 
         `50-year-old women` = b_negemot + `b_negemot:sex` * w2 + `b_negemot:age` * z2 + `b_negemot:sex:age` * w2 * z2) %>%
  mutate(contrast = `30-year-old men` - `50-year-old women`) %>% 
  pivot_longer(`30-year-old men`:contrast) %>%
  group_by(name) %>%
  summarize(mean = mean(value),
            sd   = sd(value),
            ll   = quantile(value, .025),
            ul   = quantile(value, .975)) %>% 
  mutate_if(is.double, round, digits = 4)
```

```
## # A tibble: 3 x 5
##   name                mean     sd      ll    ul
##   <chr>              <dbl>  <dbl>   <dbl> <dbl>
## 1 30-year-old men   0.370  0.0634  0.244  0.494
## 2 50-year-old women 0.318  0.0377  0.243  0.392
## 3 contrast          0.0522 0.073  -0.0928 0.197
```

Notice how our posterior $SD$ corresponded nicely to the standard error in Hayes's contrast test. And we didn't even have to worry about using the frightening Formula 9.21 on page 345. That information was contained in the posterior distribution all along. All we had to do was combine the parameter iterations with a little algebra and then `summarize()`.

For good measure, we'll compute using the equation in the second line,

$$\Delta \theta_{X \rightarrow Y} = b_4 (w_1 - w_2) + b_5 (z_1 - z_2) + b_7 (w_1 z_1 - w_2 z_2).$$


```r
post %>% 
  mutate(contrast = `b_negemot:sex` * (w1 - w2) + `b_negemot:age` * (z1 - z2) + `b_negemot:sex:age` * (w1 * z1 - w2 * z2)) %>% 
  pivot_longer(contrast) %>%
  group_by(name) %>%
  summarize(mean = mean(value),
            sd   = sd(value),
            ll   = quantile(value, .025),
            ul   = quantile(value, .975)) %>% 
  mutate_if(is.double, round, digits = 4)
```

```
## # A tibble: 1 x 5
##   name       mean    sd      ll    ul
##   <chr>     <dbl> <dbl>   <dbl> <dbl>
## 1 contrast 0.0522 0.073 -0.0928 0.197
```

Same results.

## Session info {-}


```r
sessionInfo()
```

```
## R version 4.0.4 (2021-02-15)
## Platform: x86_64-apple-darwin17.0 (64-bit)
## Running under: macOS Catalina 10.15.7
## 
## Matrix products: default
## BLAS:   /Library/Frameworks/R.framework/Versions/4.0/Resources/lib/libRblas.dylib
## LAPACK: /Library/Frameworks/R.framework/Versions/4.0/Resources/lib/libRlapack.dylib
## 
## locale:
## [1] en_US.UTF-8/en_US.UTF-8/en_US.UTF-8/C/en_US.UTF-8/en_US.UTF-8
## 
## attached base packages:
## [1] stats     graphics  grDevices utils     datasets  methods   base     
## 
## other attached packages:
##  [1] tidybayes_3.0.0 bayesplot_1.8.0 xkcd_0.0.6      extrafont_0.17  brms_2.15.0     Rcpp_1.0.6     
##  [7] forcats_0.5.1   stringr_1.4.0   dplyr_1.0.6     purrr_0.3.4     readr_1.4.0     tidyr_1.1.3    
## [13] tibble_3.1.2    ggplot2_3.3.5   tidyverse_1.3.1
## 
## loaded via a namespace (and not attached):
##   [1] readxl_1.3.1         backports_1.2.1      Hmisc_4.4-2          plyr_1.8.6          
##   [5] igraph_1.2.6         svUnit_1.0.3         splines_4.0.4        crosstalk_1.1.0.1   
##   [9] TH.data_1.0-10       rstantools_2.1.1     inline_0.3.17        digest_0.6.27       
##  [13] htmltools_0.5.1.1    rsconnect_0.8.16     fansi_0.4.2          checkmate_2.0.0     
##  [17] magrittr_2.0.1       cluster_2.1.0        modelr_0.1.8         RcppParallel_5.0.2  
##  [21] matrixStats_0.57.0   xts_0.12.1           sandwich_3.0-0       extrafontdb_1.0     
##  [25] prettyunits_1.1.1    jpeg_0.1-8.1         colorspace_2.0-0     rvest_1.0.1         
##  [29] ggdist_3.0.0         haven_2.3.1          xfun_0.23            callr_3.7.0         
##  [33] crayon_1.4.1         jsonlite_1.7.2       lme4_1.1-25          survival_3.2-10     
##  [37] zoo_1.8-8            glue_1.4.2           gtable_0.3.0         emmeans_1.5.2-1     
##  [41] V8_3.4.0             distributional_0.2.2 pkgbuild_1.2.0       Rttf2pt1_1.3.8      
##  [45] rstan_2.21.2         abind_1.4-5          scales_1.1.1         mvtnorm_1.1-1       
##  [49] DBI_1.1.0            miniUI_0.1.1.1       htmlTable_2.1.0      xtable_1.8-4        
##  [53] foreign_0.8-81       Formula_1.2-4        stats4_4.0.4         StanHeaders_2.21.0-7
##  [57] DT_0.16              htmlwidgets_1.5.3    httr_1.4.2           threejs_0.3.3       
##  [61] arrayhelpers_1.1-0   RColorBrewer_1.1-2   posterior_1.0.1      ellipsis_0.3.2      
##  [65] farver_2.1.0         pkgconfig_2.0.3      loo_2.4.1            nnet_7.3-15         
##  [69] sass_0.3.1           dbplyr_2.1.1         utf8_1.2.1           labeling_0.4.2      
##  [73] tidyselect_1.1.1     rlang_0.4.11         reshape2_1.4.4       later_1.2.0         
##  [77] munsell_0.5.0        cellranger_1.1.0     tools_4.0.4          cli_3.0.1           
##  [81] generics_0.1.0       broom_0.7.6          ggridges_0.5.3       evaluate_0.14       
##  [85] fastmap_1.1.0        processx_3.5.2       knitr_1.33           fs_1.5.0            
##  [89] nlme_3.1-152         mime_0.10            projpred_2.0.2       xml2_1.3.2          
##  [93] compiler_4.0.4       shinythemes_1.1.2    rstudioapi_0.13      png_0.1-7           
##  [97] gamm4_0.2-6          curl_4.3             reprex_2.0.0         statmod_1.4.35      
## [101] bslib_0.2.4          stringi_1.6.2        highr_0.9            ps_1.6.0            
## [105] Brobdingnag_1.2-6    lattice_0.20-41      Matrix_1.3-2         nloptr_1.2.2.2      
## [109] markdown_1.1         tensorA_0.36.2       shinyjs_2.0.0        vctrs_0.3.8         
## [113] pillar_1.6.1         lifecycle_1.0.0      jquerylib_0.1.4      bridgesampling_1.0-0
## [117] estimability_1.3     data.table_1.14.0    httpuv_1.6.0         latticeExtra_0.6-29 
## [121] R6_2.5.0             bookdown_0.22        promises_1.2.0.1     gridExtra_2.3       
## [125] codetools_0.2-18     boot_1.3-26          colourpicker_1.1.0   MASS_7.3-53         
## [129] gtools_3.8.2         assertthat_0.2.1     withr_2.4.2          shinystan_2.5.0     
## [133] multcomp_1.4-16      mgcv_1.8-33          parallel_4.0.4       hms_1.1.0           
## [137] rpart_4.1-15         grid_4.0.4           coda_0.19-4          minqa_1.2.4         
## [141] rmarkdown_2.8        shiny_1.6.0          lubridate_1.7.10     base64enc_0.1-3     
## [145] dygraphs_1.1.1.6
```

